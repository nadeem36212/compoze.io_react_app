{"ast":null,"code":"/**\n * Lazy String holder for JSON typed contents.\n */\nimport { __extends, __read, __spread } from \"tslib\";\n/**\n * Because of https://github.com/microsoft/tslib/issues/95,\n * TS 'extends' shim doesn't support extending native types like String.\n * So here we create StringWrapper that duplicate everything from String\n * class including its prototype chain. So we can extend from here.\n */\n// @ts-ignore StringWrapper implementation is not a simple constructor\nexport var StringWrapper = function StringWrapper() {\n  //@ts-ignore 'this' cannot be assigned to any, but Object.getPrototypeOf accepts any\n  var Class = Object.getPrototypeOf(this).constructor;\n  var Constructor = Function.bind.apply(String, __spread([null], arguments));\n  //@ts-ignore Call wrapped String constructor directly, don't bother typing it.\n  var instance = new Constructor();\n  Object.setPrototypeOf(instance, Class.prototype);\n  return instance;\n};\nStringWrapper.prototype = Object.create(String.prototype, {\n  constructor: {\n    value: StringWrapper,\n    enumerable: false,\n    writable: true,\n    configurable: true\n  }\n});\nObject.setPrototypeOf(StringWrapper, String);\nvar LazyJsonString = /** @class */function (_super) {\n  __extends(LazyJsonString, _super);\n  function LazyJsonString() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  LazyJsonString.prototype.deserializeJSON = function () {\n    return JSON.parse(_super.prototype.toString.call(this));\n  };\n  LazyJsonString.prototype.toJSON = function () {\n    return _super.prototype.toString.call(this);\n  };\n  LazyJsonString.fromObject = function (object) {\n    if (object instanceof LazyJsonString) {\n      return object;\n    } else if (object instanceof String || typeof object === \"string\") {\n      return new LazyJsonString(object);\n    }\n    return new LazyJsonString(JSON.stringify(object));\n  };\n  return LazyJsonString;\n}(StringWrapper);\nexport { LazyJsonString };","map":{"version":3,"sources":["../../src/lazy-json.ts"],"names":[],"mappings":"AAAA;;AAEG;;AAMH;;;;;AAKG;AACH;AACA,OAAO,IAAM,aAAa,GAAkB,SAA/B,aAAa,GAAkB;EAC1C;EACA,IAAM,KAAK,GAAG,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,WAAW;EACrD,IAAM,WAAW,GAAG,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAA,QAAA,CAAA,CAAG,IAAW,CAAA,EAAK,SAAS,CAAA,CAAE;EAC5E;EACA,IAAM,QAAQ,GAAG,IAAI,WAAW,EAAE;EAClC,MAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,KAAK,CAAC,SAAS,CAAC;EAChD,OAAO,QAAkB;AAC3B,CAAC;AACD,aAAa,CAAC,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,EAAE;EACxD,WAAW,EAAE;IACX,KAAK,EAAE,aAAa;IACpB,UAAU,EAAE,KAAK;IACjB,QAAQ,EAAE,IAAI;IACd,YAAY,EAAE;EACf;CACF,CAAC;AACF,MAAM,CAAC,cAAc,CAAC,aAAa,EAAE,MAAM,CAAC;AAE5C,IAAA,cAAA,GAAA,aAAA,UAAA,MAAA,EAAA;EAAoC,SAAA,CAAA,cAAA,EAAA,MAAA,CAAA;EAApC,SAAA,cAAA,GAAA;;EAiBA;EAhBE,cAAA,CAAA,SAAA,CAAA,eAAe,GAAf,YAAA;IACE,OAAO,IAAI,CAAC,KAAK,CAAC,MAAA,CAAA,SAAA,CAAM,QAAQ,CAAA,IAAA,CAAA,IAAA,CAAE,CAAC;EACrC,CAAC;EAED,cAAA,CAAA,SAAA,CAAA,MAAM,GAAN,YAAA;IACE,OAAO,MAAA,CAAA,SAAA,CAAM,QAAQ,CAAA,IAAA,CAAA,IAAA,CAAE;EACzB,CAAC;EAEM,cAAA,CAAA,UAAU,GAAjB,UAAkB,MAAW,EAAA;IAC3B,IAAI,MAAM,YAAY,cAAc,EAAE;MACpC,OAAO,MAAM;KACd,MAAM,IAAI,MAAM,YAAY,MAAM,IAAI,OAAO,MAAM,KAAK,QAAQ,EAAE;MACjE,OAAO,IAAI,cAAc,CAAC,MAAM,CAAC;IAClC;IACD,OAAO,IAAI,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;EACnD,CAAC;EACH,OAAA,cAAC;AAAD,CAAC,CAjBmC,aAAa,CAAA","sourcesContent":["/**\n * Lazy String holder for JSON typed contents.\n */\n\ninterface StringWrapper {\n  new (arg: any): String;\n}\n\n/**\n * Because of https://github.com/microsoft/tslib/issues/95,\n * TS 'extends' shim doesn't support extending native types like String.\n * So here we create StringWrapper that duplicate everything from String\n * class including its prototype chain. So we can extend from here.\n */\n// @ts-ignore StringWrapper implementation is not a simple constructor\nexport const StringWrapper: StringWrapper = function () {\n  //@ts-ignore 'this' cannot be assigned to any, but Object.getPrototypeOf accepts any\n  const Class = Object.getPrototypeOf(this).constructor;\n  const Constructor = Function.bind.apply(String, [null as any, ...arguments]);\n  //@ts-ignore Call wrapped String constructor directly, don't bother typing it.\n  const instance = new Constructor();\n  Object.setPrototypeOf(instance, Class.prototype);\n  return instance as String;\n};\nStringWrapper.prototype = Object.create(String.prototype, {\n  constructor: {\n    value: StringWrapper,\n    enumerable: false,\n    writable: true,\n    configurable: true,\n  },\n});\nObject.setPrototypeOf(StringWrapper, String);\n\nexport class LazyJsonString extends StringWrapper {\n  deserializeJSON(): any {\n    return JSON.parse(super.toString());\n  }\n\n  toJSON(): string {\n    return super.toString();\n  }\n\n  static fromObject(object: any): LazyJsonString {\n    if (object instanceof LazyJsonString) {\n      return object;\n    } else if (object instanceof String || typeof object === \"string\") {\n      return new LazyJsonString(object);\n    }\n    return new LazyJsonString(JSON.stringify(object));\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { HttpRequest } from \"@aws-sdk/protocol-http\";\nimport { isThrottlingError } from \"@aws-sdk/service-error-classification\";\nimport { v4 } from \"uuid\";\nimport { DEFAULT_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS, INVOCATION_ID_HEADER, REQUEST_HEADER, THROTTLING_RETRY_DELAY_BASE } from \"./constants\";\nimport { getDefaultRetryQuota } from \"./defaultRetryQuota\";\nimport { defaultDelayDecider } from \"./delayDecider\";\nimport { defaultRetryDecider } from \"./retryDecider\";\n/**\n * The default value for how many HTTP requests an SDK should make for a\n * single SDK operation invocation before giving up\n */\nexport var DEFAULT_MAX_ATTEMPTS = 3;\n/**\n * The default retry algorithm to use.\n */\nexport var DEFAULT_RETRY_MODE = \"standard\";\nvar StandardRetryStrategy = /** @class */function () {\n  function StandardRetryStrategy(maxAttemptsProvider, options) {\n    var _a, _b, _c;\n    this.maxAttemptsProvider = maxAttemptsProvider;\n    this.mode = DEFAULT_RETRY_MODE;\n    this.retryDecider = (_a = options === null || options === void 0 ? void 0 : options.retryDecider) !== null && _a !== void 0 ? _a : defaultRetryDecider;\n    this.delayDecider = (_b = options === null || options === void 0 ? void 0 : options.delayDecider) !== null && _b !== void 0 ? _b : defaultDelayDecider;\n    this.retryQuota = (_c = options === null || options === void 0 ? void 0 : options.retryQuota) !== null && _c !== void 0 ? _c : getDefaultRetryQuota(INITIAL_RETRY_TOKENS);\n  }\n  StandardRetryStrategy.prototype.shouldRetry = function (error, attempts, maxAttempts) {\n    return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);\n  };\n  StandardRetryStrategy.prototype.getMaxAttempts = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var maxAttempts, error_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n            return [4 /*yield*/, this.maxAttemptsProvider()];\n          case 1:\n            maxAttempts = _a.sent();\n            return [3 /*break*/, 3];\n          case 2:\n            error_1 = _a.sent();\n            maxAttempts = DEFAULT_MAX_ATTEMPTS;\n            return [3 /*break*/, 3];\n          case 3:\n            return [2 /*return*/, maxAttempts];\n        }\n      });\n    });\n  };\n  StandardRetryStrategy.prototype.retry = function (next, args) {\n    return __awaiter(this, void 0, void 0, function () {\n      var retryTokenAmount, attempts, totalDelay, maxAttempts, request, _loop_1, this_1, state_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            attempts = 0;\n            totalDelay = 0;\n            return [4 /*yield*/, this.getMaxAttempts()];\n          case 1:\n            maxAttempts = _a.sent();\n            request = args.request;\n            if (HttpRequest.isInstance(request)) {\n              request.headers[INVOCATION_ID_HEADER] = v4();\n            }\n            _loop_1 = function _loop_1() {\n              var _a, response, output, err_1, delay_1;\n              return __generator(this, function (_b) {\n                switch (_b.label) {\n                  case 0:\n                    _b.trys.push([0, 2,, 5]);\n                    if (HttpRequest.isInstance(request)) {\n                      request.headers[REQUEST_HEADER] = \"attempt=\" + (attempts + 1) + \"; max=\" + maxAttempts;\n                    }\n                    return [4 /*yield*/, next(args)];\n                  case 1:\n                    _a = _b.sent(), response = _a.response, output = _a.output;\n                    this_1.retryQuota.releaseRetryTokens(retryTokenAmount);\n                    output.$metadata.attempts = attempts + 1;\n                    output.$metadata.totalRetryDelay = totalDelay;\n                    return [2 /*return*/, {\n                      value: {\n                        response: response,\n                        output: output\n                      }\n                    }];\n                  case 2:\n                    err_1 = _b.sent();\n                    attempts++;\n                    if (!this_1.shouldRetry(err_1, attempts, maxAttempts)) return [3 /*break*/, 4];\n                    retryTokenAmount = this_1.retryQuota.retrieveRetryTokens(err_1);\n                    delay_1 = this_1.delayDecider(isThrottlingError(err_1) ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE, attempts);\n                    totalDelay += delay_1;\n                    return [4 /*yield*/, new Promise(function (resolve) {\n                      return setTimeout(resolve, delay_1);\n                    })];\n                  case 3:\n                    _b.sent();\n                    return [2 /*return*/, \"continue\"];\n                  case 4:\n                    if (!err_1.$metadata) {\n                      err_1.$metadata = {};\n                    }\n                    err_1.$metadata.attempts = attempts;\n                    err_1.$metadata.totalRetryDelay = totalDelay;\n                    throw err_1;\n                  case 5:\n                    return [2 /*return*/];\n                }\n              });\n            };\n\n            this_1 = this;\n            _a.label = 2;\n          case 2:\n            if (!true) return [3 /*break*/, 4];\n            return [5 /*yield**/, _loop_1()];\n          case 3:\n            state_1 = _a.sent();\n            if (typeof state_1 === \"object\") return [2 /*return*/, state_1.value];\n            return [3 /*break*/, 2];\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  return StandardRetryStrategy;\n}();\nexport { StandardRetryStrategy };","map":{"version":3,"sources":["../../src/defaultStrategy.ts"],"names":[],"mappings":"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","sourcesContent":["import { HttpRequest } from \"@aws-sdk/protocol-http\";\nimport { isThrottlingError } from \"@aws-sdk/service-error-classification\";\nimport { SdkError } from \"@aws-sdk/smithy-client\";\nimport { FinalizeHandler, FinalizeHandlerArguments, MetadataBearer, Provider, RetryStrategy } from \"@aws-sdk/types\";\nimport { v4 } from \"uuid\";\n\nimport {\n  DEFAULT_RETRY_DELAY_BASE,\n  INITIAL_RETRY_TOKENS,\n  INVOCATION_ID_HEADER,\n  REQUEST_HEADER,\n  THROTTLING_RETRY_DELAY_BASE,\n} from \"./constants\";\nimport { getDefaultRetryQuota } from \"./defaultRetryQuota\";\nimport { defaultDelayDecider } from \"./delayDecider\";\nimport { defaultRetryDecider } from \"./retryDecider\";\n\n/**\n * The default value for how many HTTP requests an SDK should make for a\n * single SDK operation invocation before giving up\n */\nexport const DEFAULT_MAX_ATTEMPTS = 3;\n\n/**\n * The default retry algorithm to use.\n */\nexport const DEFAULT_RETRY_MODE = \"standard\";\n\n/**\n * Determines whether an error is retryable based on the number of retries\n * already attempted, the HTTP status code, and the error received (if any).\n *\n * @param error         The error encountered.\n */\nexport interface RetryDecider {\n  (error: SdkError): boolean;\n}\n\n/**\n * Determines the number of milliseconds to wait before retrying an action.\n *\n * @param delayBase The base delay (in milliseconds).\n * @param attempts  The number of times the action has already been tried.\n */\nexport interface DelayDecider {\n  (delayBase: number, attempts: number): number;\n}\n\n/**\n * Interface that specifies the retry quota behavior.\n */\nexport interface RetryQuota {\n  /**\n   * returns true if retry tokens are available from the retry quota bucket.\n   */\n  hasRetryTokens: (error: SdkError) => boolean;\n\n  /**\n   * returns token amount from the retry quota bucket.\n   * throws error is retry tokens are not available.\n   */\n  retrieveRetryTokens: (error: SdkError) => number;\n\n  /**\n   * releases tokens back to the retry quota.\n   */\n  releaseRetryTokens: (releaseCapacityAmount?: number) => void;\n}\n\n/**\n * Strategy options to be passed to StandardRetryStrategy\n */\nexport interface StandardRetryStrategyOptions {\n  retryDecider?: RetryDecider;\n  delayDecider?: DelayDecider;\n  retryQuota?: RetryQuota;\n}\n\nexport class StandardRetryStrategy implements RetryStrategy {\n  private retryDecider: RetryDecider;\n  private delayDecider: DelayDecider;\n  private retryQuota: RetryQuota;\n  public readonly mode = DEFAULT_RETRY_MODE;\n\n  constructor(private readonly maxAttemptsProvider: Provider<number>, options?: StandardRetryStrategyOptions) {\n    this.retryDecider = options?.retryDecider ?? defaultRetryDecider;\n    this.delayDecider = options?.delayDecider ?? defaultDelayDecider;\n    this.retryQuota = options?.retryQuota ?? getDefaultRetryQuota(INITIAL_RETRY_TOKENS);\n  }\n\n  private shouldRetry(error: SdkError, attempts: number, maxAttempts: number) {\n    return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);\n  }\n\n  private async getMaxAttempts() {\n    let maxAttempts: number;\n    try {\n      maxAttempts = await this.maxAttemptsProvider();\n    } catch (error) {\n      maxAttempts = DEFAULT_MAX_ATTEMPTS;\n    }\n    return maxAttempts;\n  }\n\n  async retry<Input extends object, Ouput extends MetadataBearer>(\n    next: FinalizeHandler<Input, Ouput>,\n    args: FinalizeHandlerArguments<Input>\n  ) {\n    let retryTokenAmount;\n    let attempts = 0;\n    let totalDelay = 0;\n\n    const maxAttempts = await this.getMaxAttempts();\n\n    const { request } = args;\n    if (HttpRequest.isInstance(request)) {\n      request.headers[INVOCATION_ID_HEADER] = v4();\n    }\n\n    while (true) {\n      try {\n        if (HttpRequest.isInstance(request)) {\n          request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;\n        }\n        const { response, output } = await next(args);\n\n        this.retryQuota.releaseRetryTokens(retryTokenAmount);\n        output.$metadata.attempts = attempts + 1;\n        output.$metadata.totalRetryDelay = totalDelay;\n\n        return { response, output };\n      } catch (err) {\n        attempts++;\n        if (this.shouldRetry(err as SdkError, attempts, maxAttempts)) {\n          retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);\n          const delay = this.delayDecider(\n            isThrottlingError(err) ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE,\n            attempts\n          );\n          totalDelay += delay;\n\n          await new Promise((resolve) => setTimeout(resolve, delay));\n          continue;\n        }\n\n        if (!err.$metadata) {\n          err.$metadata = {};\n        }\n\n        err.$metadata.attempts = attempts;\n        err.$metadata.totalRetryDelay = totalDelay;\n        throw err;\n      }\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
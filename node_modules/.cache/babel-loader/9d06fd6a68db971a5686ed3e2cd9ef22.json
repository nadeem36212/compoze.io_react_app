{"ast":null,"code":"import { __values } from \"tslib\";\nimport { ProviderError } from \"./ProviderError\";\n/**\n * Compose a single credential provider function from multiple credential\n * providers. The first provider in the argument list will always be invoked;\n * subsequent providers in the list will be invoked in the order in which the\n * were received if the preceding provider did not successfully resolve.\n *\n * If no providers were received or no provider resolves successfully, the\n * returned promise will be rejected.\n */\nexport function chain() {\n  var providers = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    providers[_i] = arguments[_i];\n  }\n  return function () {\n    var e_1, _a;\n    var promise = Promise.reject(new ProviderError(\"No providers in chain\"));\n    var _loop_1 = function _loop_1(provider) {\n      promise = promise.catch(function (err) {\n        if (err === null || err === void 0 ? void 0 : err.tryNextLink) {\n          return provider();\n        }\n        throw err;\n      });\n    };\n    try {\n      for (var providers_1 = __values(providers), providers_1_1 = providers_1.next(); !providers_1_1.done; providers_1_1 = providers_1.next()) {\n        var provider = providers_1_1.value;\n        _loop_1(provider);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (providers_1_1 && !providers_1_1.done && (_a = providers_1.return)) _a.call(providers_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return promise;\n  };\n}","map":{"version":3,"sources":["../../src/chain.ts"],"names":[],"mappings":";AAEA,SAAS,aAAa,QAAQ,iBAAiB;AAE/C;;;;;;;;AAQG;AACH,OAAM,SAAU,KAAK,GAAA;EAAI,IAAA,SAAA,GAAA,EAAA;OAAA,IAAA,EAAA,GAAA,CAAgC,EAAhC,EAAA,GAAA,SAAA,CAAA,MAAgC,EAAhC,EAAA,EAAgC,EAAA;IAAhC,SAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;EACvB,OAAO,YAAA;;IACL,IAAI,OAAO,GAAe,OAAO,CAAC,MAAM,CAAC,IAAI,aAAa,CAAC,uBAAuB,CAAC,CAAC;mCACzE,QAAQ,EAAA;MACjB,OAAO,GAAG,OAAO,CAAC,KAAK,CAAC,UAAC,GAAQ,EAAA;QAC/B,IAAI,GAAG,KAAA,IAAA,IAAH,GAAG,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAH,GAAG,CAAE,WAAW,EAAE;UACpB,OAAO,QAAQ,EAAE;QAClB;QAED,MAAM,GAAG;MACX,CAAC,CAAC;;;MAPJ,KAAuB,IAAA,WAAA,GAAA,QAAA,CAAA,SAAS,CAAA,EAAA,aAAA,GAAA,WAAA,CAAA,IAAA,EAAA,EAAA,CAAA,aAAA,CAAA,IAAA,EAAA,aAAA,GAAA,WAAA,CAAA,IAAA,EAAA,EAAA;QAA3B,IAAM,QAAQ,GAAA,aAAA,CAAA,KAAA;gBAAR,QAAQ,CAAA;MAQlB;;;;;;;;;;;;IAED,OAAO,OAAO;EAChB,CAAC;AACH","sourcesContent":["import { Provider } from \"@aws-sdk/types\";\n\nimport { ProviderError } from \"./ProviderError\";\n\n/**\n * Compose a single credential provider function from multiple credential\n * providers. The first provider in the argument list will always be invoked;\n * subsequent providers in the list will be invoked in the order in which the\n * were received if the preceding provider did not successfully resolve.\n *\n * If no providers were received or no provider resolves successfully, the\n * returned promise will be rejected.\n */\nexport function chain<T>(...providers: Array<Provider<T>>): Provider<T> {\n  return () => {\n    let promise: Promise<T> = Promise.reject(new ProviderError(\"No providers in chain\"));\n    for (const provider of providers) {\n      promise = promise.catch((err: any) => {\n        if (err?.tryNextLink) {\n          return provider();\n        }\n\n        throw err;\n      });\n    }\n\n    return promise;\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
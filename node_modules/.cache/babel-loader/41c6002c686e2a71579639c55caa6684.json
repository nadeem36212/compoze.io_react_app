{"ast":null,"code":"import _isDate from \"lodash/isDate\";\nimport _includes from \"lodash/includes\";\nimport _isFunction from \"lodash/isFunction\";\nimport _sortedUniq from \"lodash/sortedUniq\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport _flatten from \"lodash/flatten\";\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\n\n/* eslint-disable no-use-before-define */\nimport React from \"react\";\nimport * as Data from \"./data\";\nimport * as Scale from \"./scale\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\"; // Private Methods\n\nfunction cleanDomain(domain, props, axis) {\n  var scaleType = Scale.getScaleType(props, axis);\n  if (scaleType !== \"log\") {\n    return domain;\n  }\n  var rules = function rules(dom) {\n    var almostZero = dom[0] < 0 || dom[1] < 0 ? -1 / Number.MAX_SAFE_INTEGER : 1 / Number.MAX_SAFE_INTEGER;\n    var domainOne = dom[0] === 0 ? almostZero : dom[0];\n    var domainTwo = dom[1] === 0 ? almostZero : dom[1];\n    return [domainOne, domainTwo];\n  };\n  return rules(domain);\n}\nfunction getDomainPadding(props, axis) {\n  var formatPadding = function formatPadding(padding) {\n    return Array.isArray(padding) ? {\n      left: padding[0],\n      right: padding[1]\n    } : {\n      left: padding,\n      right: padding\n    };\n  };\n  return _isPlainObject(props.domainPadding) ? formatPadding(props.domainPadding[axis]) : formatPadding(props.domainPadding);\n}\nfunction getFlatData(dataset, axis) {\n  var axisKey = \"_\".concat(axis);\n  return _flatten(dataset).map(function (datum) {\n    return datum[axisKey] && datum[axisKey][1] !== undefined ? datum[axisKey][1] : datum[axisKey];\n  });\n}\nfunction getExtremeFromData(dataset, axis) {\n  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"min\";\n  var getExtreme = function getExtreme(arr) {\n    return type === \"max\" ? Math.max.apply(Math, _toConsumableArray(arr)) : Math.min.apply(Math, _toConsumableArray(arr));\n  };\n  var initialValue = type === \"max\" ? -Infinity : Infinity;\n  var containsDate = false;\n  var result = _flatten(dataset).reduce(function (memo, datum) {\n    var current0 = datum[\"_\".concat(axis, \"0\")] !== undefined ? datum[\"_\".concat(axis, \"0\")] : datum[\"_\".concat(axis)];\n    var current1 = datum[\"_\".concat(axis, \"1\")] !== undefined ? datum[\"_\".concat(axis, \"1\")] : datum[\"_\".concat(axis)];\n    var current = getExtreme([current0, current1]);\n    containsDate = containsDate || current0 instanceof Date || current1 instanceof Date;\n    return getExtreme([memo, current]);\n  }, initialValue);\n  return containsDate ? new Date(result) : result;\n} // eslint-disable-next-line max-statements\n\nfunction padDomain(domain, props, axis) {\n  if (!props.domainPadding) {\n    return domain;\n  }\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  var padding = getDomainPadding(props, axis);\n  if (!padding.left && !padding.right) {\n    return domain;\n  }\n  var min = Collection.getMinValue(domain);\n  var max = Collection.getMaxValue(domain);\n  var currentAxis = Helpers.getCurrentAxis(axis, props.horizontal);\n  var range = Helpers.getRange(props, currentAxis);\n  var rangeExtent = Math.abs(range[0] - range[1]);\n  var paddedRangeExtent = Math.max(rangeExtent - padding.left - padding.right, 1);\n  var paddedDomainExtent = Math.abs(max.valueOf() - min.valueOf()) / paddedRangeExtent * rangeExtent;\n  var simplePadding = {\n    left: paddedDomainExtent * padding.left / rangeExtent,\n    right: paddedDomainExtent * padding.right / rangeExtent\n  };\n  var paddedDomain = {\n    min: min.valueOf() - simplePadding.left,\n    max: max.valueOf() + simplePadding.right\n  };\n  var singleQuadrantDomainPadding = _isPlainObject(props.singleQuadrantDomainPadding) ? props.singleQuadrantDomainPadding[axis] : props.singleQuadrantDomainPadding;\n  var addsQuadrants = min >= 0 && paddedDomain.min <= 0 || max <= 0 && paddedDomain.max >= 0;\n  var adjust = function adjust(val, type) {\n    var coerce = type === \"min\" && min >= 0 && val <= 0 || type === \"max\" && max <= 0 && val >= 0;\n    return coerce ? 0 : val;\n  };\n  if (addsQuadrants && singleQuadrantDomainPadding !== false) {\n    // Naive initial padding calculation\n    var initialPadding = {\n      // @ts-expect-error `max/min` might be dates\n      left: Math.abs(max - min) * padding.left / rangeExtent,\n      // @ts-expect-error `max/min` might be dates\n      right: Math.abs(max - min) * padding.right / rangeExtent\n    }; // Adjust the domain by the initial padding\n\n    var adjustedDomain = {\n      min: adjust(min.valueOf() - initialPadding.left, \"min\"),\n      max: adjust(max.valueOf() + initialPadding.right, \"max\")\n    }; // re-calculate padding, taking the adjusted domain into account\n\n    var finalPadding = {\n      left: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.left / rangeExtent,\n      right: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.right / rangeExtent\n    }; // Adjust the domain by the final padding\n\n    paddedDomain = {\n      min: adjust(min.valueOf() - finalPadding.left, \"min\"),\n      max: adjust(max.valueOf() + finalPadding.right, \"max\")\n    };\n  } // default to minDomain / maxDomain if they exist\n\n  var finalDomain = {\n    min: minDomain !== undefined ? minDomain : paddedDomain.min,\n    max: maxDomain !== undefined ? maxDomain : paddedDomain.max\n  };\n  return min instanceof Date || max instanceof Date ? getDomainFromMinMax(new Date(finalDomain.min), new Date(finalDomain.max)) : getDomainFromMinMax(finalDomain.min, finalDomain.max);\n} // Public Methods\n\n/**\n * Returns a getDomain function\n * @param {Function} getDomainFromDataFunction: a function that takes props and axis and\n * returns a domain based on data\n * @param {Function} formatDomainFunction: a function that takes domain, props, and axis and\n * returns a formatted domain\n * @returns {Function} a function that takes props and axis and returns a formatted domain\n */\n\nexport function createDomainFunction(getDomainFromDataFunction, formatDomainFunction) {\n  getDomainFromDataFunction = _isFunction(getDomainFromDataFunction) ? getDomainFromDataFunction : getDomainFromData;\n  formatDomainFunction = _isFunction(formatDomainFunction) ? formatDomainFunction : formatDomain;\n  return function (props, axis) {\n    var propsDomain = getDomainFromProps(props, axis);\n    if (propsDomain) {\n      return formatDomainFunction(propsDomain, props, axis);\n    }\n    var categories = Data.getCategories(props, axis);\n    var domain = categories ? getDomainFromCategories(props, axis, categories) : getDomainFromDataFunction(props, axis);\n    return domain ? formatDomainFunction(domain, props, axis) : undefined;\n  };\n}\n/**\n * Returns a formatted domain.\n * @param {Array} domain: a domain in the form of a two element array\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} a domain in the form of a two element array\n */\n\nexport function formatDomain(domain, props, axis) {\n  return cleanDomain(padDomain(domain, props, axis), props, axis);\n}\n/**\n * Returns a domain for a given axis based on props, category, or data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\n\nexport function getDomain(props, axis) {\n  return createDomainFunction()(props, axis);\n}\n/**\n * Returns a domain based on categories if they exist\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} categories: an array of categories corresponding to a given axis\n * @returns {Array|undefined} returns a domain from categories or undefined\n */\n\nexport function getDomainFromCategories(props, axis, categories) {\n  categories = categories || Data.getCategories(props, axis);\n  var polar = props.polar,\n    _props$startAngle = props.startAngle,\n    startAngle = _props$startAngle === void 0 ? 0 : _props$startAngle,\n    _props$endAngle = props.endAngle,\n    endAngle = _props$endAngle === void 0 ? 360 : _props$endAngle;\n  if (!categories) {\n    return undefined;\n  }\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  var stringArray = Collection.containsStrings(categories) ? Data.getStringsFromCategories(props, axis) : [];\n  var stringMap = stringArray.length === 0 ? null : stringArray.reduce(function (memo, string, index) {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n  var categoryValues = stringMap ? categories.map(function (value) {\n    return stringMap[value];\n  }) : categories;\n  var min = minDomain !== undefined ? minDomain : Collection.getMinValue(categoryValues);\n  var max = maxDomain !== undefined ? maxDomain : Collection.getMaxValue(categoryValues);\n  var categoryDomain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(categoryDomain, categoryValues) : categoryDomain;\n}\n/**\n * Returns a domain from a dataset for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} dataset: an array of data\n * @returns {Array} the domain based on data\n */\n\nexport function getDomainFromData(props, axis, dataset) {\n  dataset = dataset || Data.getData(props);\n  var polar = props.polar,\n    _props$startAngle2 = props.startAngle,\n    startAngle = _props$startAngle2 === void 0 ? 0 : _props$startAngle2,\n    _props$endAngle2 = props.endAngle,\n    endAngle = _props$endAngle2 === void 0 ? 360 : _props$endAngle2;\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  if (dataset.length < 1) {\n    return minDomain !== undefined && maxDomain !== undefined ? getDomainFromMinMax(minDomain, maxDomain) : undefined;\n  }\n  var min = minDomain !== undefined ? minDomain : getExtremeFromData(dataset, axis, \"min\");\n  var max = maxDomain !== undefined ? maxDomain : getExtremeFromData(dataset, axis, \"max\");\n  var domain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(domain, getFlatData(dataset, axis)) : domain;\n}\n/**\n * Returns a domain in the form of a two element array given a min and max value.\n * @param {Number|Date} min: the props object\n * @param {Number|Date} max: the current axis\n * @returns {Array} the minDomain based on props\n */\n\nexport function getDomainFromMinMax(min, max) {\n  var getSinglePointDomain = function getSinglePointDomain(val) {\n    // d3-scale does not properly resolve very small differences.\n    var verySmallNumber =\n    // eslint-disable-next-line no-magic-numbers\n    val === 0 ? 2 * Math.pow(10, -10) : Math.pow(10, -10);\n    var verySmallDate = 1;\n    var minVal = val instanceof Date ? new Date(Number(val) - verySmallDate) : Number(val) - verySmallNumber;\n    var maxVal = val instanceof Date ? new Date(Number(val) + verySmallDate) : Number(val) + verySmallNumber;\n    return val === 0 ? [0, maxVal] : [minVal, maxVal];\n  };\n  return Number(min) === Number(max) ? getSinglePointDomain(max) : [min, max];\n}\n/**\n * Returns a the domain for a given axis if domain is given in props\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array|undefined} the domain based on props\n */\n\nexport function getDomainFromProps(props, axis) {\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  if (_isPlainObject(props.domain) && props.domain[axis]) {\n    return props.domain[axis];\n  } else if (Array.isArray(props.domain)) {\n    return props.domain;\n  } else if (minDomain !== undefined && maxDomain !== undefined) {\n    return getDomainFromMinMax(minDomain, maxDomain);\n  }\n  return undefined;\n}\n/**\n * Returns a domain for a given axis. This method forces the domain to include\n * zero unless the domain is explicitly specified in props.\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\n\nexport function getDomainWithZero(props, axis) {\n  var propsDomain = getDomainFromProps(props, axis);\n  if (propsDomain) {\n    return propsDomain;\n  }\n  var dataset = Data.getData(props);\n  var y0Min = dataset.reduce(function (min, datum) {\n    return datum._y0 < min ? datum._y0 : min;\n  }, Infinity);\n  var ensureZero = function ensureZero(domain) {\n    if (axis === \"x\") {\n      return domain;\n    }\n    var defaultMin = y0Min !== Infinity ? y0Min : 0;\n    var maxDomainProp = getMaxFromProps(props, axis);\n    var minDomainProp = getMinFromProps(props, axis);\n    var max = maxDomainProp !== undefined ? maxDomainProp : Collection.getMaxValue(domain, defaultMin);\n    var min = minDomainProp !== undefined ? minDomainProp : Collection.getMinValue(domain, defaultMin);\n    return getDomainFromMinMax(min, max);\n  };\n  var getDomainFunction = function getDomainFunction() {\n    return getDomainFromData(props, axis, dataset);\n  };\n  var formatDomainFunction = function formatDomainFunction(domain) {\n    return formatDomain(ensureZero(domain), props, axis);\n  };\n  return createDomainFunction(getDomainFunction, formatDomainFunction)(props, axis);\n}\n/**\n * Returns the maxDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|Date|undefined} the maxDomain based on props\n */\n\nexport function getMaxFromProps(props, axis) {\n  if (_isPlainObject(props.maxDomain) && props.maxDomain[axis] !== undefined) {\n    return props.maxDomain[axis];\n  }\n  return typeof props.maxDomain === \"number\" || _isDate(props.maxDomain) ? props.maxDomain : undefined;\n}\n/**\n * Returns the minDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|Date|undefined} the minDomain based on props\n */\n\nexport function getMinFromProps(props, axis) {\n  if (_isPlainObject(props.minDomain) && props.minDomain[axis] !== undefined) {\n    return props.minDomain[axis];\n  }\n  return typeof props.minDomain === \"number\" || _isDate(props.minDomain) ? props.minDomain : undefined;\n}\n/**\n * Returns a symmetrically padded domain for polar charts\n * @param {Array} domain: the original domain\n * @param {Array} values: a flat array of values corresponding to either tickValues, or data values\n * for a given dimension i.e. only x values.\n * @returns {Array} the symmetric domain\n */\n\nexport function getSymmetricDomain(domain, values) {\n  var processedData = _sortedUniq(values.sort(function (a, b) {\n    return a - b;\n  }));\n  var step = processedData[1] - processedData[0];\n  return [domain[0], domain[1] + step];\n}\n/**\n * Checks whether a given component can be used to calculate domain\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\n\nexport function isDomainComponent(component) {\n  var getRole = function getRole(child) {\n    return child && child.type ? child.type.role : \"\";\n  };\n  var role = getRole(component);\n  if (role === \"portal\") {\n    var children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n  var whitelist = [\"area\", \"axis\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"histogram\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return _includes(whitelist, role);\n}","map":{"version":3,"names":["_isDate","_includes","_isFunction","_sortedUniq","_isPlainObject","_flatten","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","iter","Symbol","iterator","isArray","len","length","i","arr2","React","Data","Scale","Helpers","Collection","cleanDomain","domain","props","axis","scaleType","getScaleType","rules","dom","almostZero","Number","MAX_SAFE_INTEGER","domainOne","domainTwo","getDomainPadding","formatPadding","padding","left","right","domainPadding","getFlatData","dataset","axisKey","concat","map","datum","undefined","getExtremeFromData","type","arguments","getExtreme","Math","max","apply","min","initialValue","Infinity","containsDate","result","reduce","memo","current0","current1","current","Date","padDomain","minDomain","getMinFromProps","maxDomain","getMaxFromProps","getMinValue","getMaxValue","currentAxis","getCurrentAxis","horizontal","range","getRange","rangeExtent","abs","paddedRangeExtent","paddedDomainExtent","valueOf","simplePadding","paddedDomain","singleQuadrantDomainPadding","addsQuadrants","adjust","val","coerce","initialPadding","adjustedDomain","finalPadding","finalDomain","getDomainFromMinMax","createDomainFunction","getDomainFromDataFunction","formatDomainFunction","getDomainFromData","formatDomain","propsDomain","getDomainFromProps","categories","getCategories","getDomainFromCategories","getDomain","polar","_props$startAngle","startAngle","_props$endAngle","endAngle","stringArray","containsStrings","getStringsFromCategories","stringMap","string","index","categoryValues","value","categoryDomain","getSymmetricDomain","getData","_props$startAngle2","_props$endAngle2","getSinglePointDomain","verySmallNumber","pow","verySmallDate","minVal","maxVal","getDomainWithZero","y0Min","_y0","ensureZero","defaultMin","maxDomainProp","minDomainProp","getDomainFunction","values","processedData","sort","a","b","step","isDomainComponent","component","getRole","child","role","children","Children","toArray","whitelist"],"sources":["/Users/naeem/syntaxroot/compoze.io_react_app/node_modules/victory-core/es/victory-util/domain.js"],"sourcesContent":["import _isDate from \"lodash/isDate\";\nimport _includes from \"lodash/includes\";\nimport _isFunction from \"lodash/isFunction\";\nimport _sortedUniq from \"lodash/sortedUniq\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport _flatten from \"lodash/flatten\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/* eslint-disable no-use-before-define */\nimport React from \"react\";\nimport * as Data from \"./data\";\nimport * as Scale from \"./scale\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\"; // Private Methods\n\nfunction cleanDomain(domain, props, axis) {\n  var scaleType = Scale.getScaleType(props, axis);\n\n  if (scaleType !== \"log\") {\n    return domain;\n  }\n\n  var rules = function (dom) {\n    var almostZero = dom[0] < 0 || dom[1] < 0 ? -1 / Number.MAX_SAFE_INTEGER : 1 / Number.MAX_SAFE_INTEGER;\n    var domainOne = dom[0] === 0 ? almostZero : dom[0];\n    var domainTwo = dom[1] === 0 ? almostZero : dom[1];\n    return [domainOne, domainTwo];\n  };\n\n  return rules(domain);\n}\n\nfunction getDomainPadding(props, axis) {\n  var formatPadding = function (padding) {\n    return Array.isArray(padding) ? {\n      left: padding[0],\n      right: padding[1]\n    } : {\n      left: padding,\n      right: padding\n    };\n  };\n\n  return _isPlainObject(props.domainPadding) ? formatPadding(props.domainPadding[axis]) : formatPadding(props.domainPadding);\n}\n\nfunction getFlatData(dataset, axis) {\n  var axisKey = \"_\".concat(axis);\n  return _flatten(dataset).map(function (datum) {\n    return datum[axisKey] && datum[axisKey][1] !== undefined ? datum[axisKey][1] : datum[axisKey];\n  });\n}\n\nfunction getExtremeFromData(dataset, axis) {\n  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"min\";\n\n  var getExtreme = function (arr) {\n    return type === \"max\" ? Math.max.apply(Math, _toConsumableArray(arr)) : Math.min.apply(Math, _toConsumableArray(arr));\n  };\n\n  var initialValue = type === \"max\" ? -Infinity : Infinity;\n  var containsDate = false;\n\n  var result = _flatten(dataset).reduce(function (memo, datum) {\n    var current0 = datum[\"_\".concat(axis, \"0\")] !== undefined ? datum[\"_\".concat(axis, \"0\")] : datum[\"_\".concat(axis)];\n    var current1 = datum[\"_\".concat(axis, \"1\")] !== undefined ? datum[\"_\".concat(axis, \"1\")] : datum[\"_\".concat(axis)];\n    var current = getExtreme([current0, current1]);\n    containsDate = containsDate || current0 instanceof Date || current1 instanceof Date;\n    return getExtreme([memo, current]);\n  }, initialValue);\n\n  return containsDate ? new Date(result) : result;\n} // eslint-disable-next-line max-statements\n\n\nfunction padDomain(domain, props, axis) {\n  if (!props.domainPadding) {\n    return domain;\n  }\n\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  var padding = getDomainPadding(props, axis);\n\n  if (!padding.left && !padding.right) {\n    return domain;\n  }\n\n  var min = Collection.getMinValue(domain);\n  var max = Collection.getMaxValue(domain);\n  var currentAxis = Helpers.getCurrentAxis(axis, props.horizontal);\n  var range = Helpers.getRange(props, currentAxis);\n  var rangeExtent = Math.abs(range[0] - range[1]);\n  var paddedRangeExtent = Math.max(rangeExtent - padding.left - padding.right, 1);\n  var paddedDomainExtent = Math.abs(max.valueOf() - min.valueOf()) / paddedRangeExtent * rangeExtent;\n  var simplePadding = {\n    left: paddedDomainExtent * padding.left / rangeExtent,\n    right: paddedDomainExtent * padding.right / rangeExtent\n  };\n  var paddedDomain = {\n    min: min.valueOf() - simplePadding.left,\n    max: max.valueOf() + simplePadding.right\n  };\n  var singleQuadrantDomainPadding = _isPlainObject(props.singleQuadrantDomainPadding) ? props.singleQuadrantDomainPadding[axis] : props.singleQuadrantDomainPadding;\n  var addsQuadrants = min >= 0 && paddedDomain.min <= 0 || max <= 0 && paddedDomain.max >= 0;\n\n  var adjust = function (val, type) {\n    var coerce = type === \"min\" && min >= 0 && val <= 0 || type === \"max\" && max <= 0 && val >= 0;\n    return coerce ? 0 : val;\n  };\n\n  if (addsQuadrants && singleQuadrantDomainPadding !== false) {\n    // Naive initial padding calculation\n    var initialPadding = {\n      // @ts-expect-error `max/min` might be dates\n      left: Math.abs(max - min) * padding.left / rangeExtent,\n      // @ts-expect-error `max/min` might be dates\n      right: Math.abs(max - min) * padding.right / rangeExtent\n    }; // Adjust the domain by the initial padding\n\n    var adjustedDomain = {\n      min: adjust(min.valueOf() - initialPadding.left, \"min\"),\n      max: adjust(max.valueOf() + initialPadding.right, \"max\")\n    }; // re-calculate padding, taking the adjusted domain into account\n\n    var finalPadding = {\n      left: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.left / rangeExtent,\n      right: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.right / rangeExtent\n    }; // Adjust the domain by the final padding\n\n    paddedDomain = {\n      min: adjust(min.valueOf() - finalPadding.left, \"min\"),\n      max: adjust(max.valueOf() + finalPadding.right, \"max\")\n    };\n  } // default to minDomain / maxDomain if they exist\n\n\n  var finalDomain = {\n    min: minDomain !== undefined ? minDomain : paddedDomain.min,\n    max: maxDomain !== undefined ? maxDomain : paddedDomain.max\n  };\n  return min instanceof Date || max instanceof Date ? getDomainFromMinMax(new Date(finalDomain.min), new Date(finalDomain.max)) : getDomainFromMinMax(finalDomain.min, finalDomain.max);\n} // Public Methods\n\n/**\n * Returns a getDomain function\n * @param {Function} getDomainFromDataFunction: a function that takes props and axis and\n * returns a domain based on data\n * @param {Function} formatDomainFunction: a function that takes domain, props, and axis and\n * returns a formatted domain\n * @returns {Function} a function that takes props and axis and returns a formatted domain\n */\n\n\nexport function createDomainFunction(getDomainFromDataFunction, formatDomainFunction) {\n  getDomainFromDataFunction = _isFunction(getDomainFromDataFunction) ? getDomainFromDataFunction : getDomainFromData;\n  formatDomainFunction = _isFunction(formatDomainFunction) ? formatDomainFunction : formatDomain;\n  return function (props, axis) {\n    var propsDomain = getDomainFromProps(props, axis);\n\n    if (propsDomain) {\n      return formatDomainFunction(propsDomain, props, axis);\n    }\n\n    var categories = Data.getCategories(props, axis);\n    var domain = categories ? getDomainFromCategories(props, axis, categories) : getDomainFromDataFunction(props, axis);\n    return domain ? formatDomainFunction(domain, props, axis) : undefined;\n  };\n}\n/**\n * Returns a formatted domain.\n * @param {Array} domain: a domain in the form of a two element array\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} a domain in the form of a two element array\n */\n\nexport function formatDomain(domain, props, axis) {\n  return cleanDomain(padDomain(domain, props, axis), props, axis);\n}\n/**\n * Returns a domain for a given axis based on props, category, or data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\n\nexport function getDomain(props, axis) {\n  return createDomainFunction()(props, axis);\n}\n/**\n * Returns a domain based on categories if they exist\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} categories: an array of categories corresponding to a given axis\n * @returns {Array|undefined} returns a domain from categories or undefined\n */\n\nexport function getDomainFromCategories(props, axis, categories) {\n  categories = categories || Data.getCategories(props, axis);\n  var polar = props.polar,\n      _props$startAngle = props.startAngle,\n      startAngle = _props$startAngle === void 0 ? 0 : _props$startAngle,\n      _props$endAngle = props.endAngle,\n      endAngle = _props$endAngle === void 0 ? 360 : _props$endAngle;\n\n  if (!categories) {\n    return undefined;\n  }\n\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  var stringArray = Collection.containsStrings(categories) ? Data.getStringsFromCategories(props, axis) : [];\n  var stringMap = stringArray.length === 0 ? null : stringArray.reduce(function (memo, string, index) {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n  var categoryValues = stringMap ? categories.map(function (value) {\n    return stringMap[value];\n  }) : categories;\n  var min = minDomain !== undefined ? minDomain : Collection.getMinValue(categoryValues);\n  var max = maxDomain !== undefined ? maxDomain : Collection.getMaxValue(categoryValues);\n  var categoryDomain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(categoryDomain, categoryValues) : categoryDomain;\n}\n/**\n * Returns a domain from a dataset for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} dataset: an array of data\n * @returns {Array} the domain based on data\n */\n\nexport function getDomainFromData(props, axis, dataset) {\n  dataset = dataset || Data.getData(props);\n  var polar = props.polar,\n      _props$startAngle2 = props.startAngle,\n      startAngle = _props$startAngle2 === void 0 ? 0 : _props$startAngle2,\n      _props$endAngle2 = props.endAngle,\n      endAngle = _props$endAngle2 === void 0 ? 360 : _props$endAngle2;\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n\n  if (dataset.length < 1) {\n    return minDomain !== undefined && maxDomain !== undefined ? getDomainFromMinMax(minDomain, maxDomain) : undefined;\n  }\n\n  var min = minDomain !== undefined ? minDomain : getExtremeFromData(dataset, axis, \"min\");\n  var max = maxDomain !== undefined ? maxDomain : getExtremeFromData(dataset, axis, \"max\");\n  var domain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(domain, getFlatData(dataset, axis)) : domain;\n}\n/**\n * Returns a domain in the form of a two element array given a min and max value.\n * @param {Number|Date} min: the props object\n * @param {Number|Date} max: the current axis\n * @returns {Array} the minDomain based on props\n */\n\nexport function getDomainFromMinMax(min, max) {\n  var getSinglePointDomain = function (val) {\n    // d3-scale does not properly resolve very small differences.\n    var verySmallNumber = // eslint-disable-next-line no-magic-numbers\n    val === 0 ? 2 * Math.pow(10, -10) : Math.pow(10, -10);\n    var verySmallDate = 1;\n    var minVal = val instanceof Date ? new Date(Number(val) - verySmallDate) : Number(val) - verySmallNumber;\n    var maxVal = val instanceof Date ? new Date(Number(val) + verySmallDate) : Number(val) + verySmallNumber;\n    return val === 0 ? [0, maxVal] : [minVal, maxVal];\n  };\n\n  return Number(min) === Number(max) ? getSinglePointDomain(max) : [min, max];\n}\n/**\n * Returns a the domain for a given axis if domain is given in props\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array|undefined} the domain based on props\n */\n\nexport function getDomainFromProps(props, axis) {\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n\n  if (_isPlainObject(props.domain) && props.domain[axis]) {\n    return props.domain[axis];\n  } else if (Array.isArray(props.domain)) {\n    return props.domain;\n  } else if (minDomain !== undefined && maxDomain !== undefined) {\n    return getDomainFromMinMax(minDomain, maxDomain);\n  }\n\n  return undefined;\n}\n/**\n * Returns a domain for a given axis. This method forces the domain to include\n * zero unless the domain is explicitly specified in props.\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\n\nexport function getDomainWithZero(props, axis) {\n  var propsDomain = getDomainFromProps(props, axis);\n\n  if (propsDomain) {\n    return propsDomain;\n  }\n\n  var dataset = Data.getData(props);\n  var y0Min = dataset.reduce(function (min, datum) {\n    return datum._y0 < min ? datum._y0 : min;\n  }, Infinity);\n\n  var ensureZero = function (domain) {\n    if (axis === \"x\") {\n      return domain;\n    }\n\n    var defaultMin = y0Min !== Infinity ? y0Min : 0;\n    var maxDomainProp = getMaxFromProps(props, axis);\n    var minDomainProp = getMinFromProps(props, axis);\n    var max = maxDomainProp !== undefined ? maxDomainProp : Collection.getMaxValue(domain, defaultMin);\n    var min = minDomainProp !== undefined ? minDomainProp : Collection.getMinValue(domain, defaultMin);\n    return getDomainFromMinMax(min, max);\n  };\n\n  var getDomainFunction = function () {\n    return getDomainFromData(props, axis, dataset);\n  };\n\n  var formatDomainFunction = function (domain) {\n    return formatDomain(ensureZero(domain), props, axis);\n  };\n\n  return createDomainFunction(getDomainFunction, formatDomainFunction)(props, axis);\n}\n/**\n * Returns the maxDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|Date|undefined} the maxDomain based on props\n */\n\nexport function getMaxFromProps(props, axis) {\n  if (_isPlainObject(props.maxDomain) && props.maxDomain[axis] !== undefined) {\n    return props.maxDomain[axis];\n  }\n\n  return typeof props.maxDomain === \"number\" || _isDate(props.maxDomain) ? props.maxDomain : undefined;\n}\n/**\n * Returns the minDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|Date|undefined} the minDomain based on props\n */\n\nexport function getMinFromProps(props, axis) {\n  if (_isPlainObject(props.minDomain) && props.minDomain[axis] !== undefined) {\n    return props.minDomain[axis];\n  }\n\n  return typeof props.minDomain === \"number\" || _isDate(props.minDomain) ? props.minDomain : undefined;\n}\n/**\n * Returns a symmetrically padded domain for polar charts\n * @param {Array} domain: the original domain\n * @param {Array} values: a flat array of values corresponding to either tickValues, or data values\n * for a given dimension i.e. only x values.\n * @returns {Array} the symmetric domain\n */\n\nexport function getSymmetricDomain(domain, values) {\n  var processedData = _sortedUniq(values.sort(function (a, b) {\n    return a - b;\n  }));\n\n  var step = processedData[1] - processedData[0];\n  return [domain[0], domain[1] + step];\n}\n/**\n * Checks whether a given component can be used to calculate domain\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\n\nexport function isDomainComponent(component) {\n  var getRole = function (child) {\n    return child && child.type ? child.type.role : \"\";\n  };\n\n  var role = getRole(component);\n\n  if (role === \"portal\") {\n    var children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n\n  var whitelist = [\"area\", \"axis\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"histogram\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return _includes(whitelist, role);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}
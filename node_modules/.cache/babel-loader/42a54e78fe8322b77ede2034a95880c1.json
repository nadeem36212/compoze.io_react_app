{"ast":null,"code":"import _omitBy from \"lodash/omitBy\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _includes from \"lodash/includes\";\nimport _isEqual from \"lodash/isEqual\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _orderBy from \"lodash/orderBy\";\nimport _property from \"lodash/property\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport _isFunction from \"lodash/isFunction\";\nimport _last from \"lodash/last\";\nimport _range from \"lodash/range\";\nimport _uniq from \"lodash/uniq\";\nimport _assign from \"lodash/assign\";\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\n\n/* eslint-disable no-use-before-define */\nimport React from \"react\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\";\nimport * as Scale from \"./scale\";\nimport * as Immutable from \"./immutable\"; // Private Functions\n\nfunction parseDatum(datum) {\n  var immutableDatumWhitelist = {\n    errorX: true,\n    errorY: true\n  };\n  return Immutable.isImmutable(datum) ? Immutable.shallowToJS(datum, immutableDatumWhitelist) : datum;\n}\nfunction getLength(data) {\n  return Immutable.isIterable(data) ? data.size : data.length;\n} // Returns generated data for a given axis based on domain and sample from props\n\nfunction generateDataArray(props, axis) {\n  var propsDomain = _isPlainObject(props.domain) ? props.domain[axis] : props.domain;\n  var domain = propsDomain || Scale.getBaseScale(props, axis).domain();\n  var samples = props.samples || 1;\n  var domainMax = Math.max.apply(Math, _toConsumableArray(domain));\n  var domainMin = Math.min.apply(Math, _toConsumableArray(domain));\n  var step = (domainMax - domainMin) / samples;\n  var values = _range(domainMin, domainMax, step);\n  return _last(values) === domainMax ? values : values.concat(domainMax);\n} // Returns sorted data. If no sort keys are provided, data is returned unaltered.\n\nfunction sortData(dataset, sortKey) {\n  var sortOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"ascending\";\n  if (!sortKey) {\n    return dataset;\n  } // Ensures previous VictoryLine api for sortKey prop stays consistent\n\n  if (sortKey === \"x\" || sortKey === \"y\") {\n    sortKey = \"_\".concat(sortKey);\n  }\n  var order = sortOrder === \"ascending\" ? \"asc\" : \"desc\";\n  return _orderBy(dataset, sortKey, order);\n} // This method will remove data points that break certain scales. (log scale only)\n\nfunction cleanData(dataset, props) {\n  var smallNumber = 1 / Number.MAX_SAFE_INTEGER;\n  var scaleType = {\n    x: Scale.getScaleType(props, \"x\"),\n    y: Scale.getScaleType(props, \"y\")\n  };\n  if (scaleType.x !== \"log\" && scaleType.y !== \"log\") {\n    return dataset;\n  }\n  var rules = function rules(datum, axis) {\n    return scaleType[axis] === \"log\" ? datum[\"_\".concat(axis)] !== 0 : true;\n  };\n  var sanitize = function sanitize(datum) {\n    var _x = rules(datum, \"x\") ? datum._x : smallNumber;\n    var _y = rules(datum, \"y\") ? datum._y : smallNumber;\n    var _y0 = rules(datum, \"y0\") ? datum._y0 : smallNumber;\n    return _assign({}, datum, {\n      _x: _x,\n      _y: _y,\n      _y0: _y0\n    });\n  };\n  return dataset.map(function (datum) {\n    if (rules(datum, \"x\") && rules(datum, \"y\") && rules(datum, \"y0\")) {\n      return datum;\n    }\n    return sanitize(datum);\n  });\n} // Returns a data accessor given an eventKey prop\n\nfunction getEventKey(key) {\n  // creates a data accessor function\n  // given a property key, path, array index, or null for identity.\n  if (_isFunction(key)) {\n    return key;\n  } else if (key === null || key === undefined) {\n    return function () {\n      return undefined;\n    };\n  } // otherwise, assume it is an array index, property key or path (_.property handles all three)\n\n  return _property(key);\n} // Returns data with an eventKey prop added to each datum\n\nfunction addEventKeys(props, data) {\n  var hasEventKeyAccessor = !!props.eventKey;\n  var eventKeyAccessor = getEventKey(props.eventKey);\n  return data.map(function (datum, index) {\n    if (datum.eventKey !== undefined) {\n      return datum;\n    } else if (hasEventKeyAccessor) {\n      var eventKey = eventKeyAccessor(datum, index);\n      return eventKey !== undefined ? _assign({\n        eventKey: eventKey\n      }, datum) : datum;\n    }\n    return datum;\n  });\n} // Exported Functions\n// This method will remove data points that fall outside of the desired domain (non-continuous charts only)\n\nexport function formatDataFromDomain(dataset, domain, defaultBaseline) {\n  var exists = function exists(val) {\n    return val !== undefined;\n  };\n  var minDomainX = Collection.getMinValue(domain.x);\n  var maxDomainX = Collection.getMaxValue(domain.x);\n  var minDomainY = Collection.getMinValue(domain.y);\n  var maxDomainY = Collection.getMaxValue(domain.y);\n  var underMin = function underMin(min) {\n    return function (val) {\n      return exists(val) && val < min;\n    };\n  };\n  var overMax = function overMax(max) {\n    return function (val) {\n      return exists(val) && val > max;\n    };\n  };\n  var isUnderMinX = underMin(minDomainX);\n  var isUnderMinY = underMin(minDomainY);\n  var isOverMaxX = overMax(maxDomainX);\n  var isOverMaxY = overMax(maxDomainY); // eslint-disable-next-line complexity\n\n  return dataset.map(function (datum) {\n    var _x = datum._x,\n      _y = datum._y,\n      _y0 = datum._y0,\n      _y1 = datum._y1; // single x point less than min domain\n\n    if (isUnderMinX(_x) || isOverMaxX(_x)) _x = null;\n    var baseline = exists(_y0) ? _y0 : defaultBaseline;\n    var value = exists(_y1) ? _y1 : _y;\n    if (!exists(value)) return datum; // value only and less than min domain or greater than max domain\n\n    if (!exists(baseline) && (isUnderMinY(value) || isOverMaxY(value))) _y = null; // baseline and value are both less than min domain or both greater than max domain\n\n    if (isUnderMinY(baseline) && isUnderMinY(value) || isOverMaxY(baseline) && isOverMaxY(value)) _y = _y0 = _y1 = null; // baseline and value with only baseline below min, set baseline to minDomainY\n\n    if (isUnderMinY(baseline) && !isUnderMinY(value)) _y0 = minDomainY; // baseline and value with only baseline above max, set baseline to maxDomainY\n\n    if (isOverMaxY(baseline) && !isOverMaxY(value)) _y0 = maxDomainY;\n    return _assign({}, datum, _omitBy({\n      _x: _x,\n      _y: _y,\n      _y0: _y0,\n      _y1: _y1\n    }, _isUndefined));\n  });\n}\n/**\n * Returns an object mapping string data to numeric data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Object} an object mapping string data to numeric data\n */\n\nexport function createStringMap(props, axis) {\n  var stringsFromAxes = getStringsFromAxes(props, axis);\n  var stringsFromCategories = getStringsFromCategories(props, axis);\n  var stringsFromData = getStringsFromData(props, axis);\n  var allStrings = _uniq([].concat(_toConsumableArray(stringsFromAxes), _toConsumableArray(stringsFromCategories), _toConsumableArray(stringsFromData)));\n  return allStrings.length === 0 ? null : allStrings.reduce(function (memo, string, index) {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n}\n/**\n * Reduces the size of a data array, such that it is <= maxPoints.\n * @param {Array} data: an array of data; must be sorted\n * @param {Number} maxPoints: maximum number of data points to return\n * @param {Number} startingIndex: the index of the data[0] *in the entire dataset*; this function\n                   assumes `data` param is a subset of larger dataset that has been zoommed\n  * @returns {Array} an array of data, a subset of data param\n  */\n\nexport function downsample(data, maxPoints) {\n  var startingIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  // ensures that the downampling of data while zooming looks good.\n  var dataLength = getLength(data);\n  if (dataLength > maxPoints) {\n    // limit k to powers of 2, e.g. 64, 128, 256\n    // so that the same points will be chosen reliably, reducing flicker on zoom\n    var k = Math.pow(2, Math.ceil(Math.log2(dataLength / maxPoints)));\n    return data.filter(\n    // ensure modulo is always calculated from same reference: i + startingIndex\n    function (d, i) {\n      return (i + startingIndex) % k === 0;\n    });\n  }\n  return data;\n}\n/**\n * Returns formatted data. Data accessors are applied, and string values are replaced.\n * @param {Array} dataset: the original domain\n * @param {Object} props: the props object\n * @param {Array} expectedKeys: an array of expected data keys\n * @returns {Array} the formatted data\n */\n\nexport function formatData(dataset, props, expectedKeys) {\n  var isArrayOrIterable = Array.isArray(dataset) || Immutable.isIterable(dataset);\n  if (!isArrayOrIterable || getLength(dataset) < 1) {\n    return [];\n  }\n  var defaultKeys = [\"x\", \"y\", \"y0\"];\n  expectedKeys = Array.isArray(expectedKeys) ? expectedKeys : defaultKeys;\n  var createAccessor = function createAccessor(name) {\n    return Helpers.createAccessor(props[name] !== undefined ? props[name] : name);\n  };\n  var accessor = expectedKeys.reduce(function (memo, type) {\n    memo[type] = createAccessor(type);\n    return memo;\n  }, {});\n  var preformattedData = _isEqual(expectedKeys, defaultKeys) && props.x === \"_x\" && props.y === \"_y\" && props.y0 === \"_y0\";\n  var stringMap;\n  if (preformattedData === false) {\n    // stringMap is not required if the data is preformatted\n    stringMap = {\n      x: expectedKeys.indexOf(\"x\") !== -1 ? createStringMap(props, \"x\") : undefined,\n      y: expectedKeys.indexOf(\"y\") !== -1 ? createStringMap(props, \"y\") : undefined,\n      y0: expectedKeys.indexOf(\"y0\") !== -1 ? createStringMap(props, \"y\") : undefined\n    };\n  }\n  var data = preformattedData ? dataset : dataset.reduce(function (dataArr, datum, index) {\n    // eslint-disable-line complexity\n    datum = parseDatum(datum);\n    var fallbackValues = {\n      x: index,\n      y: datum\n    };\n    var processedValues = expectedKeys.reduce(function (memo, type) {\n      var processedValue = accessor[type](datum);\n      var value = processedValue !== undefined ? processedValue : fallbackValues[type];\n      if (value !== undefined) {\n        if (typeof value === \"string\" && stringMap[type]) {\n          memo[\"\".concat(type, \"Name\")] = value;\n          memo[\"_\".concat(type)] = stringMap[type][value];\n        } else {\n          memo[\"_\".concat(type)] = value;\n        }\n      }\n      return memo;\n    }, {});\n    var formattedDatum = _assign({}, processedValues, datum);\n    if (!_isEmpty(formattedDatum)) {\n      dataArr.push(formattedDatum);\n    }\n    return dataArr;\n  }, []);\n  var sortedData = sortData(data, props.sortKey, props.sortOrder);\n  var cleanedData = cleanData(sortedData, props);\n  return addEventKeys(props, cleanedData);\n}\n/**\n * Returns generated x and y data based on domain and sample from props\n * @param {Object} props: the props object\n * @returns {Array} an array of data\n */\n\nexport function generateData(props) {\n  var xValues = generateDataArray(props, \"x\");\n  var yValues = generateDataArray(props, \"y\");\n  var values = xValues.map(function (x, i) {\n    return {\n      x: x,\n      y: yValues[i]\n    };\n  });\n  return values;\n}\n/**\n * Returns an array of categories for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of categories\n */\n\nexport function getCategories(props, axis) {\n  return props.categories && !Array.isArray(props.categories) ? props.categories[axis] : props.categories;\n}\n/**\n * Returns an array of formatted data\n * @param {Object} props: the props object\n * @returns {Array} an array of data\n */\n\nexport function getData(props) {\n  return props.data ? formatData(props.data, props) : formatData(generateData(props), props);\n}\n/**\n * Returns an array of strings from axis tickValues for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\nexport function getStringsFromAxes(props, axis) {\n  var tickValues = props.tickValues,\n    tickFormat = props.tickFormat;\n  var tickValueArray;\n  if (!tickValues || !Array.isArray(tickValues) && !tickValues[axis]) {\n    tickValueArray = tickFormat && Array.isArray(tickFormat) ? tickFormat : [];\n  } else {\n    tickValueArray = tickValues[axis] || tickValues;\n  }\n  return tickValueArray.filter(function (val) {\n    return typeof val === \"string\";\n  });\n}\n/**\n * Returns an array of strings from categories for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\nexport function getStringsFromCategories(props, axis) {\n  if (!props.categories) {\n    return [];\n  }\n  var categories = getCategories(props, axis);\n  var categoryStrings = categories && categories.filter(function (val) {\n    return typeof val === \"string\";\n  });\n  return categoryStrings ? Collection.removeUndefined(categoryStrings) : [];\n}\n/**\n * Returns an array of strings from data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\nexport function getStringsFromData(props, axis) {\n  var isArrayOrIterable = Array.isArray(props.data) || Immutable.isIterable(props.data);\n  if (!isArrayOrIterable) {\n    return [];\n  }\n  var key = props[axis] === undefined ? axis : props[axis];\n  var accessor = Helpers.createAccessor(key); // support immutable data\n\n  var data = props.data.reduce(function (memo, d) {\n    memo.push(parseDatum(d));\n    return memo;\n  }, []);\n  var sortedData = sortData(data, props.sortKey, props.sortOrder);\n  var dataStrings = sortedData.reduce(function (dataArr, datum) {\n    datum = parseDatum(datum);\n    dataArr.push(accessor(datum));\n    return dataArr;\n  }, []).filter(function (datum) {\n    return typeof datum === \"string\";\n  }); // return a unique set of strings\n\n  return dataStrings.reduce(function (prev, curr) {\n    if (curr !== undefined && curr !== null && prev.indexOf(curr) === -1) {\n      prev.push(curr);\n    }\n    return prev;\n  }, []);\n}\n/**\n * Checks whether a given component can be used to calculate data\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\n\nexport function isDataComponent(component) {\n  var getRole = function getRole(child) {\n    return child && child.type ? child.type.role : \"\";\n  };\n  var role = getRole(component);\n  if (role === \"portal\") {\n    var children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n  var whitelist = [\"area\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"histogram\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return _includes(whitelist, role);\n}","map":{"version":3,"names":["_omitBy","_isUndefined","_includes","_isEqual","_isEmpty","_orderBy","_property","_isPlainObject","_isFunction","_last","_range","_uniq","_assign","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","iter","Symbol","iterator","isArray","len","length","i","arr2","React","Helpers","Collection","Scale","Immutable","parseDatum","datum","immutableDatumWhitelist","errorX","errorY","isImmutable","shallowToJS","getLength","data","isIterable","size","generateDataArray","props","axis","propsDomain","domain","getBaseScale","samples","domainMax","Math","max","apply","domainMin","min","step","values","concat","sortData","dataset","sortKey","sortOrder","arguments","undefined","order","cleanData","smallNumber","Number","MAX_SAFE_INTEGER","scaleType","x","getScaleType","y","rules","sanitize","_x","_y","_y0","map","getEventKey","key","addEventKeys","hasEventKeyAccessor","eventKey","eventKeyAccessor","index","formatDataFromDomain","defaultBaseline","exists","val","minDomainX","getMinValue","maxDomainX","getMaxValue","minDomainY","maxDomainY","underMin","overMax","isUnderMinX","isUnderMinY","isOverMaxX","isOverMaxY","_y1","baseline","value","createStringMap","stringsFromAxes","getStringsFromAxes","stringsFromCategories","getStringsFromCategories","stringsFromData","getStringsFromData","allStrings","reduce","memo","string","downsample","maxPoints","startingIndex","dataLength","k","pow","ceil","log2","filter","d","formatData","expectedKeys","isArrayOrIterable","defaultKeys","createAccessor","accessor","type","preformattedData","y0","stringMap","indexOf","dataArr","fallbackValues","processedValues","processedValue","formattedDatum","push","sortedData","cleanedData","generateData","xValues","yValues","getCategories","categories","getData","tickValues","tickFormat","tickValueArray","categoryStrings","removeUndefined","dataStrings","prev","curr","isDataComponent","component","getRole","child","role","children","Children","toArray","whitelist"],"sources":["/Users/naeem/syntaxroot/costdashboard-fe-redesign/node_modules/victory-core/es/victory-util/data.js"],"sourcesContent":["import _omitBy from \"lodash/omitBy\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _includes from \"lodash/includes\";\nimport _isEqual from \"lodash/isEqual\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _orderBy from \"lodash/orderBy\";\nimport _property from \"lodash/property\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport _isFunction from \"lodash/isFunction\";\nimport _last from \"lodash/last\";\nimport _range from \"lodash/range\";\nimport _uniq from \"lodash/uniq\";\nimport _assign from \"lodash/assign\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/* eslint-disable no-use-before-define */\nimport React from \"react\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\";\nimport * as Scale from \"./scale\";\nimport * as Immutable from \"./immutable\"; // Private Functions\n\nfunction parseDatum(datum) {\n  var immutableDatumWhitelist = {\n    errorX: true,\n    errorY: true\n  };\n  return Immutable.isImmutable(datum) ? Immutable.shallowToJS(datum, immutableDatumWhitelist) : datum;\n}\n\nfunction getLength(data) {\n  return Immutable.isIterable(data) ? data.size : data.length;\n} // Returns generated data for a given axis based on domain and sample from props\n\n\nfunction generateDataArray(props, axis) {\n  var propsDomain = _isPlainObject(props.domain) ? props.domain[axis] : props.domain;\n  var domain = propsDomain || Scale.getBaseScale(props, axis).domain();\n  var samples = props.samples || 1;\n  var domainMax = Math.max.apply(Math, _toConsumableArray(domain));\n  var domainMin = Math.min.apply(Math, _toConsumableArray(domain));\n  var step = (domainMax - domainMin) / samples;\n\n  var values = _range(domainMin, domainMax, step);\n\n  return _last(values) === domainMax ? values : values.concat(domainMax);\n} // Returns sorted data. If no sort keys are provided, data is returned unaltered.\n\n\nfunction sortData(dataset, sortKey) {\n  var sortOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"ascending\";\n\n  if (!sortKey) {\n    return dataset;\n  } // Ensures previous VictoryLine api for sortKey prop stays consistent\n\n\n  if (sortKey === \"x\" || sortKey === \"y\") {\n    sortKey = \"_\".concat(sortKey);\n  }\n\n  var order = sortOrder === \"ascending\" ? \"asc\" : \"desc\";\n  return _orderBy(dataset, sortKey, order);\n} // This method will remove data points that break certain scales. (log scale only)\n\n\nfunction cleanData(dataset, props) {\n  var smallNumber = 1 / Number.MAX_SAFE_INTEGER;\n  var scaleType = {\n    x: Scale.getScaleType(props, \"x\"),\n    y: Scale.getScaleType(props, \"y\")\n  };\n\n  if (scaleType.x !== \"log\" && scaleType.y !== \"log\") {\n    return dataset;\n  }\n\n  var rules = function (datum, axis) {\n    return scaleType[axis] === \"log\" ? datum[\"_\".concat(axis)] !== 0 : true;\n  };\n\n  var sanitize = function (datum) {\n    var _x = rules(datum, \"x\") ? datum._x : smallNumber;\n\n    var _y = rules(datum, \"y\") ? datum._y : smallNumber;\n\n    var _y0 = rules(datum, \"y0\") ? datum._y0 : smallNumber;\n\n    return _assign({}, datum, {\n      _x: _x,\n      _y: _y,\n      _y0: _y0\n    });\n  };\n\n  return dataset.map(function (datum) {\n    if (rules(datum, \"x\") && rules(datum, \"y\") && rules(datum, \"y0\")) {\n      return datum;\n    }\n\n    return sanitize(datum);\n  });\n} // Returns a data accessor given an eventKey prop\n\n\nfunction getEventKey(key) {\n  // creates a data accessor function\n  // given a property key, path, array index, or null for identity.\n  if (_isFunction(key)) {\n    return key;\n  } else if (key === null || key === undefined) {\n    return function () {\n      return undefined;\n    };\n  } // otherwise, assume it is an array index, property key or path (_.property handles all three)\n\n\n  return _property(key);\n} // Returns data with an eventKey prop added to each datum\n\n\nfunction addEventKeys(props, data) {\n  var hasEventKeyAccessor = !!props.eventKey;\n  var eventKeyAccessor = getEventKey(props.eventKey);\n  return data.map(function (datum, index) {\n    if (datum.eventKey !== undefined) {\n      return datum;\n    } else if (hasEventKeyAccessor) {\n      var eventKey = eventKeyAccessor(datum, index);\n      return eventKey !== undefined ? _assign({\n        eventKey: eventKey\n      }, datum) : datum;\n    }\n\n    return datum;\n  });\n} // Exported Functions\n// This method will remove data points that fall outside of the desired domain (non-continuous charts only)\n\n\nexport function formatDataFromDomain(dataset, domain, defaultBaseline) {\n  var exists = function (val) {\n    return val !== undefined;\n  };\n\n  var minDomainX = Collection.getMinValue(domain.x);\n  var maxDomainX = Collection.getMaxValue(domain.x);\n  var minDomainY = Collection.getMinValue(domain.y);\n  var maxDomainY = Collection.getMaxValue(domain.y);\n\n  var underMin = function (min) {\n    return function (val) {\n      return exists(val) && val < min;\n    };\n  };\n\n  var overMax = function (max) {\n    return function (val) {\n      return exists(val) && val > max;\n    };\n  };\n\n  var isUnderMinX = underMin(minDomainX);\n  var isUnderMinY = underMin(minDomainY);\n  var isOverMaxX = overMax(maxDomainX);\n  var isOverMaxY = overMax(maxDomainY); // eslint-disable-next-line complexity\n\n  return dataset.map(function (datum) {\n    var _x = datum._x,\n        _y = datum._y,\n        _y0 = datum._y0,\n        _y1 = datum._y1; // single x point less than min domain\n\n    if (isUnderMinX(_x) || isOverMaxX(_x)) _x = null;\n    var baseline = exists(_y0) ? _y0 : defaultBaseline;\n    var value = exists(_y1) ? _y1 : _y;\n    if (!exists(value)) return datum; // value only and less than min domain or greater than max domain\n\n    if (!exists(baseline) && (isUnderMinY(value) || isOverMaxY(value))) _y = null; // baseline and value are both less than min domain or both greater than max domain\n\n    if (isUnderMinY(baseline) && isUnderMinY(value) || isOverMaxY(baseline) && isOverMaxY(value)) _y = _y0 = _y1 = null; // baseline and value with only baseline below min, set baseline to minDomainY\n\n    if (isUnderMinY(baseline) && !isUnderMinY(value)) _y0 = minDomainY; // baseline and value with only baseline above max, set baseline to maxDomainY\n\n    if (isOverMaxY(baseline) && !isOverMaxY(value)) _y0 = maxDomainY;\n    return _assign({}, datum, _omitBy({\n      _x: _x,\n      _y: _y,\n      _y0: _y0,\n      _y1: _y1\n    }, _isUndefined));\n  });\n}\n/**\n * Returns an object mapping string data to numeric data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Object} an object mapping string data to numeric data\n */\n\nexport function createStringMap(props, axis) {\n  var stringsFromAxes = getStringsFromAxes(props, axis);\n  var stringsFromCategories = getStringsFromCategories(props, axis);\n  var stringsFromData = getStringsFromData(props, axis);\n\n  var allStrings = _uniq([].concat(_toConsumableArray(stringsFromAxes), _toConsumableArray(stringsFromCategories), _toConsumableArray(stringsFromData)));\n\n  return allStrings.length === 0 ? null : allStrings.reduce(function (memo, string, index) {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n}\n/**\n * Reduces the size of a data array, such that it is <= maxPoints.\n * @param {Array} data: an array of data; must be sorted\n * @param {Number} maxPoints: maximum number of data points to return\n * @param {Number} startingIndex: the index of the data[0] *in the entire dataset*; this function\n                   assumes `data` param is a subset of larger dataset that has been zoommed\n  * @returns {Array} an array of data, a subset of data param\n  */\n\nexport function downsample(data, maxPoints) {\n  var startingIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  // ensures that the downampling of data while zooming looks good.\n  var dataLength = getLength(data);\n\n  if (dataLength > maxPoints) {\n    // limit k to powers of 2, e.g. 64, 128, 256\n    // so that the same points will be chosen reliably, reducing flicker on zoom\n    var k = Math.pow(2, Math.ceil(Math.log2(dataLength / maxPoints)));\n    return data.filter( // ensure modulo is always calculated from same reference: i + startingIndex\n    function (d, i) {\n      return (i + startingIndex) % k === 0;\n    });\n  }\n\n  return data;\n}\n/**\n * Returns formatted data. Data accessors are applied, and string values are replaced.\n * @param {Array} dataset: the original domain\n * @param {Object} props: the props object\n * @param {Array} expectedKeys: an array of expected data keys\n * @returns {Array} the formatted data\n */\n\nexport function formatData(dataset, props, expectedKeys) {\n  var isArrayOrIterable = Array.isArray(dataset) || Immutable.isIterable(dataset);\n\n  if (!isArrayOrIterable || getLength(dataset) < 1) {\n    return [];\n  }\n\n  var defaultKeys = [\"x\", \"y\", \"y0\"];\n  expectedKeys = Array.isArray(expectedKeys) ? expectedKeys : defaultKeys;\n\n  var createAccessor = function (name) {\n    return Helpers.createAccessor(props[name] !== undefined ? props[name] : name);\n  };\n\n  var accessor = expectedKeys.reduce(function (memo, type) {\n    memo[type] = createAccessor(type);\n    return memo;\n  }, {});\n  var preformattedData = _isEqual(expectedKeys, defaultKeys) && props.x === \"_x\" && props.y === \"_y\" && props.y0 === \"_y0\";\n  var stringMap;\n\n  if (preformattedData === false) {\n    // stringMap is not required if the data is preformatted\n    stringMap = {\n      x: expectedKeys.indexOf(\"x\") !== -1 ? createStringMap(props, \"x\") : undefined,\n      y: expectedKeys.indexOf(\"y\") !== -1 ? createStringMap(props, \"y\") : undefined,\n      y0: expectedKeys.indexOf(\"y0\") !== -1 ? createStringMap(props, \"y\") : undefined\n    };\n  }\n\n  var data = preformattedData ? dataset : dataset.reduce(function (dataArr, datum, index) {\n    // eslint-disable-line complexity\n    datum = parseDatum(datum);\n    var fallbackValues = {\n      x: index,\n      y: datum\n    };\n    var processedValues = expectedKeys.reduce(function (memo, type) {\n      var processedValue = accessor[type](datum);\n      var value = processedValue !== undefined ? processedValue : fallbackValues[type];\n\n      if (value !== undefined) {\n        if (typeof value === \"string\" && stringMap[type]) {\n          memo[\"\".concat(type, \"Name\")] = value;\n          memo[\"_\".concat(type)] = stringMap[type][value];\n        } else {\n          memo[\"_\".concat(type)] = value;\n        }\n      }\n\n      return memo;\n    }, {});\n\n    var formattedDatum = _assign({}, processedValues, datum);\n\n    if (!_isEmpty(formattedDatum)) {\n      dataArr.push(formattedDatum);\n    }\n\n    return dataArr;\n  }, []);\n  var sortedData = sortData(data, props.sortKey, props.sortOrder);\n  var cleanedData = cleanData(sortedData, props);\n  return addEventKeys(props, cleanedData);\n}\n/**\n * Returns generated x and y data based on domain and sample from props\n * @param {Object} props: the props object\n * @returns {Array} an array of data\n */\n\nexport function generateData(props) {\n  var xValues = generateDataArray(props, \"x\");\n  var yValues = generateDataArray(props, \"y\");\n  var values = xValues.map(function (x, i) {\n    return {\n      x: x,\n      y: yValues[i]\n    };\n  });\n  return values;\n}\n/**\n * Returns an array of categories for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of categories\n */\n\nexport function getCategories(props, axis) {\n  return props.categories && !Array.isArray(props.categories) ? props.categories[axis] : props.categories;\n}\n/**\n * Returns an array of formatted data\n * @param {Object} props: the props object\n * @returns {Array} an array of data\n */\n\nexport function getData(props) {\n  return props.data ? formatData(props.data, props) : formatData(generateData(props), props);\n}\n/**\n * Returns an array of strings from axis tickValues for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\nexport function getStringsFromAxes(props, axis) {\n  var tickValues = props.tickValues,\n      tickFormat = props.tickFormat;\n  var tickValueArray;\n\n  if (!tickValues || !Array.isArray(tickValues) && !tickValues[axis]) {\n    tickValueArray = tickFormat && Array.isArray(tickFormat) ? tickFormat : [];\n  } else {\n    tickValueArray = tickValues[axis] || tickValues;\n  }\n\n  return tickValueArray.filter(function (val) {\n    return typeof val === \"string\";\n  });\n}\n/**\n * Returns an array of strings from categories for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\nexport function getStringsFromCategories(props, axis) {\n  if (!props.categories) {\n    return [];\n  }\n\n  var categories = getCategories(props, axis);\n  var categoryStrings = categories && categories.filter(function (val) {\n    return typeof val === \"string\";\n  });\n  return categoryStrings ? Collection.removeUndefined(categoryStrings) : [];\n}\n/**\n * Returns an array of strings from data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\nexport function getStringsFromData(props, axis) {\n  var isArrayOrIterable = Array.isArray(props.data) || Immutable.isIterable(props.data);\n\n  if (!isArrayOrIterable) {\n    return [];\n  }\n\n  var key = props[axis] === undefined ? axis : props[axis];\n  var accessor = Helpers.createAccessor(key); // support immutable data\n\n  var data = props.data.reduce(function (memo, d) {\n    memo.push(parseDatum(d));\n    return memo;\n  }, []);\n  var sortedData = sortData(data, props.sortKey, props.sortOrder);\n  var dataStrings = sortedData.reduce(function (dataArr, datum) {\n    datum = parseDatum(datum);\n    dataArr.push(accessor(datum));\n    return dataArr;\n  }, []).filter(function (datum) {\n    return typeof datum === \"string\";\n  }); // return a unique set of strings\n\n  return dataStrings.reduce(function (prev, curr) {\n    if (curr !== undefined && curr !== null && prev.indexOf(curr) === -1) {\n      prev.push(curr);\n    }\n\n    return prev;\n  }, []);\n}\n/**\n * Checks whether a given component can be used to calculate data\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\n\nexport function isDataComponent(component) {\n  var getRole = function (child) {\n    return child && child.type ? child.type.role : \"\";\n  };\n\n  var role = getRole(component);\n\n  if (role === \"portal\") {\n    var children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n\n  var whitelist = [\"area\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"histogram\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return _includes(whitelist, role);\n}"],"mappings":"AAAA,OAAOA,OAAO,MAAM,eAAe;AACnC,OAAOC,YAAY,MAAM,oBAAoB;AAC7C,OAAOC,SAAS,MAAM,iBAAiB;AACvC,OAAOC,QAAQ,MAAM,gBAAgB;AACrC,OAAOC,QAAQ,MAAM,gBAAgB;AACrC,OAAOC,QAAQ,MAAM,gBAAgB;AACrC,OAAOC,SAAS,MAAM,iBAAiB;AACvC,OAAOC,cAAc,MAAM,sBAAsB;AACjD,OAAOC,WAAW,MAAM,mBAAmB;AAC3C,OAAOC,KAAK,MAAM,aAAa;AAC/B,OAAOC,MAAM,MAAM,cAAc;AACjC,OAAOC,KAAK,MAAM,aAAa;AAC/B,OAAOC,OAAO,MAAM,eAAe;AAEnC,SAASC,kBAAkB,CAACC,GAAG,EAAE;EAAE,OAAOC,kBAAkB,CAACD,GAAG,CAAC,IAAIE,gBAAgB,CAACF,GAAG,CAAC,IAAIG,2BAA2B,CAACH,GAAG,CAAC,IAAII,kBAAkB,EAAE;AAAE;AAExJ,SAASA,kBAAkB,GAAG;EAAE,MAAM,IAAIC,SAAS,CAAC,sIAAsI,CAAC;AAAE;AAE7L,SAASF,2BAA2B,CAACG,CAAC,EAAEC,MAAM,EAAE;EAAE,IAAI,CAACD,CAAC,EAAE;EAAQ,IAAI,OAAOA,CAAC,KAAK,QAAQ,EAAE,OAAOE,iBAAiB,CAACF,CAAC,EAAEC,MAAM,CAAC;EAAE,IAAIE,CAAC,GAAGC,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACP,CAAC,CAAC,CAACQ,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EAAE,IAAIL,CAAC,KAAK,QAAQ,IAAIH,CAAC,CAACS,WAAW,EAAEN,CAAC,GAAGH,CAAC,CAACS,WAAW,CAACC,IAAI;EAAE,IAAIP,CAAC,KAAK,KAAK,IAAIA,CAAC,KAAK,KAAK,EAAE,OAAOQ,KAAK,CAACC,IAAI,CAACZ,CAAC,CAAC;EAAE,IAAIG,CAAC,KAAK,WAAW,IAAI,0CAA0C,CAACU,IAAI,CAACV,CAAC,CAAC,EAAE,OAAOD,iBAAiB,CAACF,CAAC,EAAEC,MAAM,CAAC;AAAE;AAE/Z,SAASL,gBAAgB,CAACkB,IAAI,EAAE;EAAE,IAAI,OAAOC,MAAM,KAAK,WAAW,IAAID,IAAI,CAACC,MAAM,CAACC,QAAQ,CAAC,IAAI,IAAI,IAAIF,IAAI,CAAC,YAAY,CAAC,IAAI,IAAI,EAAE,OAAOH,KAAK,CAACC,IAAI,CAACE,IAAI,CAAC;AAAE;AAE7J,SAASnB,kBAAkB,CAACD,GAAG,EAAE;EAAE,IAAIiB,KAAK,CAACM,OAAO,CAACvB,GAAG,CAAC,EAAE,OAAOQ,iBAAiB,CAACR,GAAG,CAAC;AAAE;AAE1F,SAASQ,iBAAiB,CAACR,GAAG,EAAEwB,GAAG,EAAE;EAAE,IAAIA,GAAG,IAAI,IAAI,IAAIA,GAAG,GAAGxB,GAAG,CAACyB,MAAM,EAAED,GAAG,GAAGxB,GAAG,CAACyB,MAAM;EAAE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAG,IAAIV,KAAK,CAACO,GAAG,CAAC,EAAEE,CAAC,GAAGF,GAAG,EAAEE,CAAC,EAAE,EAAE;IAAEC,IAAI,CAACD,CAAC,CAAC,GAAG1B,GAAG,CAAC0B,CAAC,CAAC;EAAE;EAAE,OAAOC,IAAI;AAAE;;AAEtL;AACA,OAAOC,KAAK,MAAM,OAAO;AACzB,OAAO,KAAKC,OAAO,MAAM,WAAW;AACpC,OAAO,KAAKC,UAAU,MAAM,cAAc;AAC1C,OAAO,KAAKC,KAAK,MAAM,SAAS;AAChC,OAAO,KAAKC,SAAS,MAAM,aAAa,CAAC,CAAC;;AAE1C,SAASC,UAAU,CAACC,KAAK,EAAE;EACzB,IAAIC,uBAAuB,GAAG;IAC5BC,MAAM,EAAE,IAAI;IACZC,MAAM,EAAE;EACV,CAAC;EACD,OAAOL,SAAS,CAACM,WAAW,CAACJ,KAAK,CAAC,GAAGF,SAAS,CAACO,WAAW,CAACL,KAAK,EAAEC,uBAAuB,CAAC,GAAGD,KAAK;AACrG;AAEA,SAASM,SAAS,CAACC,IAAI,EAAE;EACvB,OAAOT,SAAS,CAACU,UAAU,CAACD,IAAI,CAAC,GAAGA,IAAI,CAACE,IAAI,GAAGF,IAAI,CAAChB,MAAM;AAC7D,CAAC,CAAC;;AAGF,SAASmB,iBAAiB,CAACC,KAAK,EAAEC,IAAI,EAAE;EACtC,IAAIC,WAAW,GAAGtD,cAAc,CAACoD,KAAK,CAACG,MAAM,CAAC,GAAGH,KAAK,CAACG,MAAM,CAACF,IAAI,CAAC,GAAGD,KAAK,CAACG,MAAM;EAClF,IAAIA,MAAM,GAAGD,WAAW,IAAIhB,KAAK,CAACkB,YAAY,CAACJ,KAAK,EAAEC,IAAI,CAAC,CAACE,MAAM,EAAE;EACpE,IAAIE,OAAO,GAAGL,KAAK,CAACK,OAAO,IAAI,CAAC;EAChC,IAAIC,SAAS,GAAGC,IAAI,CAACC,GAAG,CAACC,KAAK,CAACF,IAAI,EAAErD,kBAAkB,CAACiD,MAAM,CAAC,CAAC;EAChE,IAAIO,SAAS,GAAGH,IAAI,CAACI,GAAG,CAACF,KAAK,CAACF,IAAI,EAAErD,kBAAkB,CAACiD,MAAM,CAAC,CAAC;EAChE,IAAIS,IAAI,GAAG,CAACN,SAAS,GAAGI,SAAS,IAAIL,OAAO;EAE5C,IAAIQ,MAAM,GAAG9D,MAAM,CAAC2D,SAAS,EAAEJ,SAAS,EAAEM,IAAI,CAAC;EAE/C,OAAO9D,KAAK,CAAC+D,MAAM,CAAC,KAAKP,SAAS,GAAGO,MAAM,GAAGA,MAAM,CAACC,MAAM,CAACR,SAAS,CAAC;AACxE,CAAC,CAAC;;AAGF,SAASS,QAAQ,CAACC,OAAO,EAAEC,OAAO,EAAE;EAClC,IAAIC,SAAS,GAAGC,SAAS,CAACvC,MAAM,GAAG,CAAC,IAAIuC,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,WAAW;EAE/F,IAAI,CAACF,OAAO,EAAE;IACZ,OAAOD,OAAO;EAChB,CAAC,CAAC;;EAGF,IAAIC,OAAO,KAAK,GAAG,IAAIA,OAAO,KAAK,GAAG,EAAE;IACtCA,OAAO,GAAG,GAAG,CAACH,MAAM,CAACG,OAAO,CAAC;EAC/B;EAEA,IAAII,KAAK,GAAGH,SAAS,KAAK,WAAW,GAAG,KAAK,GAAG,MAAM;EACtD,OAAOxE,QAAQ,CAACsE,OAAO,EAAEC,OAAO,EAAEI,KAAK,CAAC;AAC1C,CAAC,CAAC;;AAGF,SAASC,SAAS,CAACN,OAAO,EAAEhB,KAAK,EAAE;EACjC,IAAIuB,WAAW,GAAG,CAAC,GAAGC,MAAM,CAACC,gBAAgB;EAC7C,IAAIC,SAAS,GAAG;IACdC,CAAC,EAAEzC,KAAK,CAAC0C,YAAY,CAAC5B,KAAK,EAAE,GAAG,CAAC;IACjC6B,CAAC,EAAE3C,KAAK,CAAC0C,YAAY,CAAC5B,KAAK,EAAE,GAAG;EAClC,CAAC;EAED,IAAI0B,SAAS,CAACC,CAAC,KAAK,KAAK,IAAID,SAAS,CAACG,CAAC,KAAK,KAAK,EAAE;IAClD,OAAOb,OAAO;EAChB;EAEA,IAAIc,KAAK,GAAG,SAARA,KAAK,CAAazC,KAAK,EAAEY,IAAI,EAAE;IACjC,OAAOyB,SAAS,CAACzB,IAAI,CAAC,KAAK,KAAK,GAAGZ,KAAK,CAAC,GAAG,CAACyB,MAAM,CAACb,IAAI,CAAC,CAAC,KAAK,CAAC,GAAG,IAAI;EACzE,CAAC;EAED,IAAI8B,QAAQ,GAAG,SAAXA,QAAQ,CAAa1C,KAAK,EAAE;IAC9B,IAAI2C,EAAE,GAAGF,KAAK,CAACzC,KAAK,EAAE,GAAG,CAAC,GAAGA,KAAK,CAAC2C,EAAE,GAAGT,WAAW;IAEnD,IAAIU,EAAE,GAAGH,KAAK,CAACzC,KAAK,EAAE,GAAG,CAAC,GAAGA,KAAK,CAAC4C,EAAE,GAAGV,WAAW;IAEnD,IAAIW,GAAG,GAAGJ,KAAK,CAACzC,KAAK,EAAE,IAAI,CAAC,GAAGA,KAAK,CAAC6C,GAAG,GAAGX,WAAW;IAEtD,OAAOtE,OAAO,CAAC,CAAC,CAAC,EAAEoC,KAAK,EAAE;MACxB2C,EAAE,EAAEA,EAAE;MACNC,EAAE,EAAEA,EAAE;MACNC,GAAG,EAAEA;IACP,CAAC,CAAC;EACJ,CAAC;EAED,OAAOlB,OAAO,CAACmB,GAAG,CAAC,UAAU9C,KAAK,EAAE;IAClC,IAAIyC,KAAK,CAACzC,KAAK,EAAE,GAAG,CAAC,IAAIyC,KAAK,CAACzC,KAAK,EAAE,GAAG,CAAC,IAAIyC,KAAK,CAACzC,KAAK,EAAE,IAAI,CAAC,EAAE;MAChE,OAAOA,KAAK;IACd;IAEA,OAAO0C,QAAQ,CAAC1C,KAAK,CAAC;EACxB,CAAC,CAAC;AACJ,CAAC,CAAC;;AAGF,SAAS+C,WAAW,CAACC,GAAG,EAAE;EACxB;EACA;EACA,IAAIxF,WAAW,CAACwF,GAAG,CAAC,EAAE;IACpB,OAAOA,GAAG;EACZ,CAAC,MAAM,IAAIA,GAAG,KAAK,IAAI,IAAIA,GAAG,KAAKjB,SAAS,EAAE;IAC5C,OAAO,YAAY;MACjB,OAAOA,SAAS;IAClB,CAAC;EACH,CAAC,CAAC;;EAGF,OAAOzE,SAAS,CAAC0F,GAAG,CAAC;AACvB,CAAC,CAAC;;AAGF,SAASC,YAAY,CAACtC,KAAK,EAAEJ,IAAI,EAAE;EACjC,IAAI2C,mBAAmB,GAAG,CAAC,CAACvC,KAAK,CAACwC,QAAQ;EAC1C,IAAIC,gBAAgB,GAAGL,WAAW,CAACpC,KAAK,CAACwC,QAAQ,CAAC;EAClD,OAAO5C,IAAI,CAACuC,GAAG,CAAC,UAAU9C,KAAK,EAAEqD,KAAK,EAAE;IACtC,IAAIrD,KAAK,CAACmD,QAAQ,KAAKpB,SAAS,EAAE;MAChC,OAAO/B,KAAK;IACd,CAAC,MAAM,IAAIkD,mBAAmB,EAAE;MAC9B,IAAIC,QAAQ,GAAGC,gBAAgB,CAACpD,KAAK,EAAEqD,KAAK,CAAC;MAC7C,OAAOF,QAAQ,KAAKpB,SAAS,GAAGnE,OAAO,CAAC;QACtCuF,QAAQ,EAAEA;MACZ,CAAC,EAAEnD,KAAK,CAAC,GAAGA,KAAK;IACnB;IAEA,OAAOA,KAAK;EACd,CAAC,CAAC;AACJ,CAAC,CAAC;AACF;;AAGA,OAAO,SAASsD,oBAAoB,CAAC3B,OAAO,EAAEb,MAAM,EAAEyC,eAAe,EAAE;EACrE,IAAIC,MAAM,GAAG,SAATA,MAAM,CAAaC,GAAG,EAAE;IAC1B,OAAOA,GAAG,KAAK1B,SAAS;EAC1B,CAAC;EAED,IAAI2B,UAAU,GAAG9D,UAAU,CAAC+D,WAAW,CAAC7C,MAAM,CAACwB,CAAC,CAAC;EACjD,IAAIsB,UAAU,GAAGhE,UAAU,CAACiE,WAAW,CAAC/C,MAAM,CAACwB,CAAC,CAAC;EACjD,IAAIwB,UAAU,GAAGlE,UAAU,CAAC+D,WAAW,CAAC7C,MAAM,CAAC0B,CAAC,CAAC;EACjD,IAAIuB,UAAU,GAAGnE,UAAU,CAACiE,WAAW,CAAC/C,MAAM,CAAC0B,CAAC,CAAC;EAEjD,IAAIwB,QAAQ,GAAG,SAAXA,QAAQ,CAAa1C,GAAG,EAAE;IAC5B,OAAO,UAAUmC,GAAG,EAAE;MACpB,OAAOD,MAAM,CAACC,GAAG,CAAC,IAAIA,GAAG,GAAGnC,GAAG;IACjC,CAAC;EACH,CAAC;EAED,IAAI2C,OAAO,GAAG,SAAVA,OAAO,CAAa9C,GAAG,EAAE;IAC3B,OAAO,UAAUsC,GAAG,EAAE;MACpB,OAAOD,MAAM,CAACC,GAAG,CAAC,IAAIA,GAAG,GAAGtC,GAAG;IACjC,CAAC;EACH,CAAC;EAED,IAAI+C,WAAW,GAAGF,QAAQ,CAACN,UAAU,CAAC;EACtC,IAAIS,WAAW,GAAGH,QAAQ,CAACF,UAAU,CAAC;EACtC,IAAIM,UAAU,GAAGH,OAAO,CAACL,UAAU,CAAC;EACpC,IAAIS,UAAU,GAAGJ,OAAO,CAACF,UAAU,CAAC,CAAC,CAAC;;EAEtC,OAAOpC,OAAO,CAACmB,GAAG,CAAC,UAAU9C,KAAK,EAAE;IAClC,IAAI2C,EAAE,GAAG3C,KAAK,CAAC2C,EAAE;MACbC,EAAE,GAAG5C,KAAK,CAAC4C,EAAE;MACbC,GAAG,GAAG7C,KAAK,CAAC6C,GAAG;MACfyB,GAAG,GAAGtE,KAAK,CAACsE,GAAG,CAAC,CAAC;;IAErB,IAAIJ,WAAW,CAACvB,EAAE,CAAC,IAAIyB,UAAU,CAACzB,EAAE,CAAC,EAAEA,EAAE,GAAG,IAAI;IAChD,IAAI4B,QAAQ,GAAGf,MAAM,CAACX,GAAG,CAAC,GAAGA,GAAG,GAAGU,eAAe;IAClD,IAAIiB,KAAK,GAAGhB,MAAM,CAACc,GAAG,CAAC,GAAGA,GAAG,GAAG1B,EAAE;IAClC,IAAI,CAACY,MAAM,CAACgB,KAAK,CAAC,EAAE,OAAOxE,KAAK,CAAC,CAAC;;IAElC,IAAI,CAACwD,MAAM,CAACe,QAAQ,CAAC,KAAKJ,WAAW,CAACK,KAAK,CAAC,IAAIH,UAAU,CAACG,KAAK,CAAC,CAAC,EAAE5B,EAAE,GAAG,IAAI,CAAC,CAAC;;IAE/E,IAAIuB,WAAW,CAACI,QAAQ,CAAC,IAAIJ,WAAW,CAACK,KAAK,CAAC,IAAIH,UAAU,CAACE,QAAQ,CAAC,IAAIF,UAAU,CAACG,KAAK,CAAC,EAAE5B,EAAE,GAAGC,GAAG,GAAGyB,GAAG,GAAG,IAAI,CAAC,CAAC;;IAErH,IAAIH,WAAW,CAACI,QAAQ,CAAC,IAAI,CAACJ,WAAW,CAACK,KAAK,CAAC,EAAE3B,GAAG,GAAGiB,UAAU,CAAC,CAAC;;IAEpE,IAAIO,UAAU,CAACE,QAAQ,CAAC,IAAI,CAACF,UAAU,CAACG,KAAK,CAAC,EAAE3B,GAAG,GAAGkB,UAAU;IAChE,OAAOnG,OAAO,CAAC,CAAC,CAAC,EAAEoC,KAAK,EAAEhD,OAAO,CAAC;MAChC2F,EAAE,EAAEA,EAAE;MACNC,EAAE,EAAEA,EAAE;MACNC,GAAG,EAAEA,GAAG;MACRyB,GAAG,EAAEA;IACP,CAAC,EAAErH,YAAY,CAAC,CAAC;EACnB,CAAC,CAAC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASwH,eAAe,CAAC9D,KAAK,EAAEC,IAAI,EAAE;EAC3C,IAAI8D,eAAe,GAAGC,kBAAkB,CAAChE,KAAK,EAAEC,IAAI,CAAC;EACrD,IAAIgE,qBAAqB,GAAGC,wBAAwB,CAAClE,KAAK,EAAEC,IAAI,CAAC;EACjE,IAAIkE,eAAe,GAAGC,kBAAkB,CAACpE,KAAK,EAAEC,IAAI,CAAC;EAErD,IAAIoE,UAAU,GAAGrH,KAAK,CAAC,EAAE,CAAC8D,MAAM,CAAC5D,kBAAkB,CAAC6G,eAAe,CAAC,EAAE7G,kBAAkB,CAAC+G,qBAAqB,CAAC,EAAE/G,kBAAkB,CAACiH,eAAe,CAAC,CAAC,CAAC;EAEtJ,OAAOE,UAAU,CAACzF,MAAM,KAAK,CAAC,GAAG,IAAI,GAAGyF,UAAU,CAACC,MAAM,CAAC,UAAUC,IAAI,EAAEC,MAAM,EAAE9B,KAAK,EAAE;IACvF6B,IAAI,CAACC,MAAM,CAAC,GAAG9B,KAAK,GAAG,CAAC;IACxB,OAAO6B,IAAI;EACb,CAAC,EAAE,CAAC,CAAC,CAAC;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASE,UAAU,CAAC7E,IAAI,EAAE8E,SAAS,EAAE;EAC1C,IAAIC,aAAa,GAAGxD,SAAS,CAACvC,MAAM,GAAG,CAAC,IAAIuC,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;EACzF;EACA,IAAIyD,UAAU,GAAGjF,SAAS,CAACC,IAAI,CAAC;EAEhC,IAAIgF,UAAU,GAAGF,SAAS,EAAE;IAC1B;IACA;IACA,IAAIG,CAAC,GAAGtE,IAAI,CAACuE,GAAG,CAAC,CAAC,EAAEvE,IAAI,CAACwE,IAAI,CAACxE,IAAI,CAACyE,IAAI,CAACJ,UAAU,GAAGF,SAAS,CAAC,CAAC,CAAC;IACjE,OAAO9E,IAAI,CAACqF,MAAM;IAAE;IACpB,UAAUC,CAAC,EAAErG,CAAC,EAAE;MACd,OAAO,CAACA,CAAC,GAAG8F,aAAa,IAAIE,CAAC,KAAK,CAAC;IACtC,CAAC,CAAC;EACJ;EAEA,OAAOjF,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASuF,UAAU,CAACnE,OAAO,EAAEhB,KAAK,EAAEoF,YAAY,EAAE;EACvD,IAAIC,iBAAiB,GAAGjH,KAAK,CAACM,OAAO,CAACsC,OAAO,CAAC,IAAI7B,SAAS,CAACU,UAAU,CAACmB,OAAO,CAAC;EAE/E,IAAI,CAACqE,iBAAiB,IAAI1F,SAAS,CAACqB,OAAO,CAAC,GAAG,CAAC,EAAE;IAChD,OAAO,EAAE;EACX;EAEA,IAAIsE,WAAW,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,CAAC;EAClCF,YAAY,GAAGhH,KAAK,CAACM,OAAO,CAAC0G,YAAY,CAAC,GAAGA,YAAY,GAAGE,WAAW;EAEvE,IAAIC,cAAc,GAAG,SAAjBA,cAAc,CAAapH,IAAI,EAAE;IACnC,OAAOa,OAAO,CAACuG,cAAc,CAACvF,KAAK,CAAC7B,IAAI,CAAC,KAAKiD,SAAS,GAAGpB,KAAK,CAAC7B,IAAI,CAAC,GAAGA,IAAI,CAAC;EAC/E,CAAC;EAED,IAAIqH,QAAQ,GAAGJ,YAAY,CAACd,MAAM,CAAC,UAAUC,IAAI,EAAEkB,IAAI,EAAE;IACvDlB,IAAI,CAACkB,IAAI,CAAC,GAAGF,cAAc,CAACE,IAAI,CAAC;IACjC,OAAOlB,IAAI;EACb,CAAC,EAAE,CAAC,CAAC,CAAC;EACN,IAAImB,gBAAgB,GAAGlJ,QAAQ,CAAC4I,YAAY,EAAEE,WAAW,CAAC,IAAItF,KAAK,CAAC2B,CAAC,KAAK,IAAI,IAAI3B,KAAK,CAAC6B,CAAC,KAAK,IAAI,IAAI7B,KAAK,CAAC2F,EAAE,KAAK,KAAK;EACxH,IAAIC,SAAS;EAEb,IAAIF,gBAAgB,KAAK,KAAK,EAAE;IAC9B;IACAE,SAAS,GAAG;MACVjE,CAAC,EAAEyD,YAAY,CAACS,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG/B,eAAe,CAAC9D,KAAK,EAAE,GAAG,CAAC,GAAGoB,SAAS;MAC7ES,CAAC,EAAEuD,YAAY,CAACS,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG/B,eAAe,CAAC9D,KAAK,EAAE,GAAG,CAAC,GAAGoB,SAAS;MAC7EuE,EAAE,EAAEP,YAAY,CAACS,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG/B,eAAe,CAAC9D,KAAK,EAAE,GAAG,CAAC,GAAGoB;IACxE,CAAC;EACH;EAEA,IAAIxB,IAAI,GAAG8F,gBAAgB,GAAG1E,OAAO,GAAGA,OAAO,CAACsD,MAAM,CAAC,UAAUwB,OAAO,EAAEzG,KAAK,EAAEqD,KAAK,EAAE;IACtF;IACArD,KAAK,GAAGD,UAAU,CAACC,KAAK,CAAC;IACzB,IAAI0G,cAAc,GAAG;MACnBpE,CAAC,EAAEe,KAAK;MACRb,CAAC,EAAExC;IACL,CAAC;IACD,IAAI2G,eAAe,GAAGZ,YAAY,CAACd,MAAM,CAAC,UAAUC,IAAI,EAAEkB,IAAI,EAAE;MAC9D,IAAIQ,cAAc,GAAGT,QAAQ,CAACC,IAAI,CAAC,CAACpG,KAAK,CAAC;MAC1C,IAAIwE,KAAK,GAAGoC,cAAc,KAAK7E,SAAS,GAAG6E,cAAc,GAAGF,cAAc,CAACN,IAAI,CAAC;MAEhF,IAAI5B,KAAK,KAAKzC,SAAS,EAAE;QACvB,IAAI,OAAOyC,KAAK,KAAK,QAAQ,IAAI+B,SAAS,CAACH,IAAI,CAAC,EAAE;UAChDlB,IAAI,CAAC,EAAE,CAACzD,MAAM,CAAC2E,IAAI,EAAE,MAAM,CAAC,CAAC,GAAG5B,KAAK;UACrCU,IAAI,CAAC,GAAG,CAACzD,MAAM,CAAC2E,IAAI,CAAC,CAAC,GAAGG,SAAS,CAACH,IAAI,CAAC,CAAC5B,KAAK,CAAC;QACjD,CAAC,MAAM;UACLU,IAAI,CAAC,GAAG,CAACzD,MAAM,CAAC2E,IAAI,CAAC,CAAC,GAAG5B,KAAK;QAChC;MACF;MAEA,OAAOU,IAAI;IACb,CAAC,EAAE,CAAC,CAAC,CAAC;IAEN,IAAI2B,cAAc,GAAGjJ,OAAO,CAAC,CAAC,CAAC,EAAE+I,eAAe,EAAE3G,KAAK,CAAC;IAExD,IAAI,CAAC5C,QAAQ,CAACyJ,cAAc,CAAC,EAAE;MAC7BJ,OAAO,CAACK,IAAI,CAACD,cAAc,CAAC;IAC9B;IAEA,OAAOJ,OAAO;EAChB,CAAC,EAAE,EAAE,CAAC;EACN,IAAIM,UAAU,GAAGrF,QAAQ,CAACnB,IAAI,EAAEI,KAAK,CAACiB,OAAO,EAAEjB,KAAK,CAACkB,SAAS,CAAC;EAC/D,IAAImF,WAAW,GAAG/E,SAAS,CAAC8E,UAAU,EAAEpG,KAAK,CAAC;EAC9C,OAAOsC,YAAY,CAACtC,KAAK,EAAEqG,WAAW,CAAC;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,YAAY,CAACtG,KAAK,EAAE;EAClC,IAAIuG,OAAO,GAAGxG,iBAAiB,CAACC,KAAK,EAAE,GAAG,CAAC;EAC3C,IAAIwG,OAAO,GAAGzG,iBAAiB,CAACC,KAAK,EAAE,GAAG,CAAC;EAC3C,IAAIa,MAAM,GAAG0F,OAAO,CAACpE,GAAG,CAAC,UAAUR,CAAC,EAAE9C,CAAC,EAAE;IACvC,OAAO;MACL8C,CAAC,EAAEA,CAAC;MACJE,CAAC,EAAE2E,OAAO,CAAC3H,CAAC;IACd,CAAC;EACH,CAAC,CAAC;EACF,OAAOgC,MAAM;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAAS4F,aAAa,CAACzG,KAAK,EAAEC,IAAI,EAAE;EACzC,OAAOD,KAAK,CAAC0G,UAAU,IAAI,CAACtI,KAAK,CAACM,OAAO,CAACsB,KAAK,CAAC0G,UAAU,CAAC,GAAG1G,KAAK,CAAC0G,UAAU,CAACzG,IAAI,CAAC,GAAGD,KAAK,CAAC0G,UAAU;AACzG;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,OAAO,CAAC3G,KAAK,EAAE;EAC7B,OAAOA,KAAK,CAACJ,IAAI,GAAGuF,UAAU,CAACnF,KAAK,CAACJ,IAAI,EAAEI,KAAK,CAAC,GAAGmF,UAAU,CAACmB,YAAY,CAACtG,KAAK,CAAC,EAAEA,KAAK,CAAC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASgE,kBAAkB,CAAChE,KAAK,EAAEC,IAAI,EAAE;EAC9C,IAAI2G,UAAU,GAAG5G,KAAK,CAAC4G,UAAU;IAC7BC,UAAU,GAAG7G,KAAK,CAAC6G,UAAU;EACjC,IAAIC,cAAc;EAElB,IAAI,CAACF,UAAU,IAAI,CAACxI,KAAK,CAACM,OAAO,CAACkI,UAAU,CAAC,IAAI,CAACA,UAAU,CAAC3G,IAAI,CAAC,EAAE;IAClE6G,cAAc,GAAGD,UAAU,IAAIzI,KAAK,CAACM,OAAO,CAACmI,UAAU,CAAC,GAAGA,UAAU,GAAG,EAAE;EAC5E,CAAC,MAAM;IACLC,cAAc,GAAGF,UAAU,CAAC3G,IAAI,CAAC,IAAI2G,UAAU;EACjD;EAEA,OAAOE,cAAc,CAAC7B,MAAM,CAAC,UAAUnC,GAAG,EAAE;IAC1C,OAAO,OAAOA,GAAG,KAAK,QAAQ;EAChC,CAAC,CAAC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASoB,wBAAwB,CAAClE,KAAK,EAAEC,IAAI,EAAE;EACpD,IAAI,CAACD,KAAK,CAAC0G,UAAU,EAAE;IACrB,OAAO,EAAE;EACX;EAEA,IAAIA,UAAU,GAAGD,aAAa,CAACzG,KAAK,EAAEC,IAAI,CAAC;EAC3C,IAAI8G,eAAe,GAAGL,UAAU,IAAIA,UAAU,CAACzB,MAAM,CAAC,UAAUnC,GAAG,EAAE;IACnE,OAAO,OAAOA,GAAG,KAAK,QAAQ;EAChC,CAAC,CAAC;EACF,OAAOiE,eAAe,GAAG9H,UAAU,CAAC+H,eAAe,CAACD,eAAe,CAAC,GAAG,EAAE;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAAS3C,kBAAkB,CAACpE,KAAK,EAAEC,IAAI,EAAE;EAC9C,IAAIoF,iBAAiB,GAAGjH,KAAK,CAACM,OAAO,CAACsB,KAAK,CAACJ,IAAI,CAAC,IAAIT,SAAS,CAACU,UAAU,CAACG,KAAK,CAACJ,IAAI,CAAC;EAErF,IAAI,CAACyF,iBAAiB,EAAE;IACtB,OAAO,EAAE;EACX;EAEA,IAAIhD,GAAG,GAAGrC,KAAK,CAACC,IAAI,CAAC,KAAKmB,SAAS,GAAGnB,IAAI,GAAGD,KAAK,CAACC,IAAI,CAAC;EACxD,IAAIuF,QAAQ,GAAGxG,OAAO,CAACuG,cAAc,CAAClD,GAAG,CAAC,CAAC,CAAC;;EAE5C,IAAIzC,IAAI,GAAGI,KAAK,CAACJ,IAAI,CAAC0E,MAAM,CAAC,UAAUC,IAAI,EAAEW,CAAC,EAAE;IAC9CX,IAAI,CAAC4B,IAAI,CAAC/G,UAAU,CAAC8F,CAAC,CAAC,CAAC;IACxB,OAAOX,IAAI;EACb,CAAC,EAAE,EAAE,CAAC;EACN,IAAI6B,UAAU,GAAGrF,QAAQ,CAACnB,IAAI,EAAEI,KAAK,CAACiB,OAAO,EAAEjB,KAAK,CAACkB,SAAS,CAAC;EAC/D,IAAI+F,WAAW,GAAGb,UAAU,CAAC9B,MAAM,CAAC,UAAUwB,OAAO,EAAEzG,KAAK,EAAE;IAC5DA,KAAK,GAAGD,UAAU,CAACC,KAAK,CAAC;IACzByG,OAAO,CAACK,IAAI,CAACX,QAAQ,CAACnG,KAAK,CAAC,CAAC;IAC7B,OAAOyG,OAAO;EAChB,CAAC,EAAE,EAAE,CAAC,CAACb,MAAM,CAAC,UAAU5F,KAAK,EAAE;IAC7B,OAAO,OAAOA,KAAK,KAAK,QAAQ;EAClC,CAAC,CAAC,CAAC,CAAC;;EAEJ,OAAO4H,WAAW,CAAC3C,MAAM,CAAC,UAAU4C,IAAI,EAAEC,IAAI,EAAE;IAC9C,IAAIA,IAAI,KAAK/F,SAAS,IAAI+F,IAAI,KAAK,IAAI,IAAID,IAAI,CAACrB,OAAO,CAACsB,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;MACpED,IAAI,CAACf,IAAI,CAACgB,IAAI,CAAC;IACjB;IAEA,OAAOD,IAAI;EACb,CAAC,EAAE,EAAE,CAAC;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASE,eAAe,CAACC,SAAS,EAAE;EACzC,IAAIC,OAAO,GAAG,SAAVA,OAAO,CAAaC,KAAK,EAAE;IAC7B,OAAOA,KAAK,IAAIA,KAAK,CAAC9B,IAAI,GAAG8B,KAAK,CAAC9B,IAAI,CAAC+B,IAAI,GAAG,EAAE;EACnD,CAAC;EAED,IAAIA,IAAI,GAAGF,OAAO,CAACD,SAAS,CAAC;EAE7B,IAAIG,IAAI,KAAK,QAAQ,EAAE;IACrB,IAAIC,QAAQ,GAAG1I,KAAK,CAAC2I,QAAQ,CAACC,OAAO,CAACN,SAAS,CAACrH,KAAK,CAACyH,QAAQ,CAAC;IAC/DD,IAAI,GAAGC,QAAQ,CAAC7I,MAAM,GAAG0I,OAAO,CAACG,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE;EACpD;EAEA,IAAIG,SAAS,GAAG,CAAC,MAAM,EAAE,KAAK,EAAE,SAAS,EAAE,aAAa,EAAE,UAAU,EAAE,OAAO,EAAE,WAAW,EAAE,MAAM,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,EAAE,SAAS,CAAC;EACzI,OAAOrL,SAAS,CAACqL,SAAS,EAAEJ,IAAI,CAAC;AACnC"},"metadata":{},"sourceType":"module"}
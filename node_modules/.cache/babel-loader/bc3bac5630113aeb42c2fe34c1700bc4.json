{"ast":null,"code":"var alphabetByEncoding = {};\nvar alphabetByValue = new Array(64);\nfor (var i = 0, start = \"A\".charCodeAt(0), limit = \"Z\".charCodeAt(0); i + start <= limit; i++) {\n  var char = String.fromCharCode(i + start);\n  alphabetByEncoding[char] = i;\n  alphabetByValue[i] = char;\n}\nfor (var i = 0, start = \"a\".charCodeAt(0), limit = \"z\".charCodeAt(0); i + start <= limit; i++) {\n  var char = String.fromCharCode(i + start);\n  var index = i + 26;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\nfor (var i = 0; i < 10; i++) {\n  alphabetByEncoding[i.toString(10)] = i + 52;\n  var char = i.toString(10);\n  var index = i + 52;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\nalphabetByEncoding[\"+\"] = 62;\nalphabetByValue[62] = \"+\";\nalphabetByEncoding[\"/\"] = 63;\nalphabetByValue[63] = \"/\";\nvar bitsPerLetter = 6;\nvar bitsPerByte = 8;\nvar maxLetterValue = 63;\n/**\n * Converts a base-64 encoded string to a Uint8Array of bytes.\n *\n * @param input The base-64 encoded string\n *\n * @see https://tools.ietf.org/html/rfc4648#section-4\n */\nexport function fromBase64(input) {\n  var totalByteLength = input.length / 4 * 3;\n  if (input.substr(-2) === \"==\") {\n    totalByteLength -= 2;\n  } else if (input.substr(-1) === \"=\") {\n    totalByteLength--;\n  }\n  var out = new ArrayBuffer(totalByteLength);\n  var dataView = new DataView(out);\n  for (var i = 0; i < input.length; i += 4) {\n    var bits = 0;\n    var bitLength = 0;\n    for (var j = i, limit = i + 3; j <= limit; j++) {\n      if (input[j] !== \"=\") {\n        bits |= alphabetByEncoding[input[j]] << (limit - j) * bitsPerLetter;\n        bitLength += bitsPerLetter;\n      } else {\n        bits >>= bitsPerLetter;\n      }\n    }\n    var chunkOffset = i / 4 * 3;\n    bits >>= bitLength % bitsPerByte;\n    var byteLength = Math.floor(bitLength / bitsPerByte);\n    for (var k = 0; k < byteLength; k++) {\n      var offset = (byteLength - k - 1) * bitsPerByte;\n      dataView.setUint8(chunkOffset + k, (bits & 255 << offset) >> offset);\n    }\n  }\n  return new Uint8Array(out);\n}\n/**\n * Converts a Uint8Array of binary data to a base-64 encoded string.\n *\n * @param input The binary data to encode\n *\n * @see https://tools.ietf.org/html/rfc4648#section-4\n */\nexport function toBase64(input) {\n  var str = \"\";\n  for (var i = 0; i < input.length; i += 3) {\n    var bits = 0;\n    var bitLength = 0;\n    for (var j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {\n      bits |= input[j] << (limit - j - 1) * bitsPerByte;\n      bitLength += bitsPerByte;\n    }\n    var bitClusterCount = Math.ceil(bitLength / bitsPerLetter);\n    bits <<= bitClusterCount * bitsPerLetter - bitLength;\n    for (var k = 1; k <= bitClusterCount; k++) {\n      var offset = (bitClusterCount - k) * bitsPerLetter;\n      str += alphabetByValue[(bits & maxLetterValue << offset) >> offset];\n    }\n    str += \"==\".slice(0, 4 - bitClusterCount);\n  }\n  return str;\n}","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["const alphabetByEncoding: { [key: string]: number } = {};\nconst alphabetByValue: Array<string> = new Array(64);\n\nfor (let i = 0, start = \"A\".charCodeAt(0), limit = \"Z\".charCodeAt(0); i + start <= limit; i++) {\n  const char = String.fromCharCode(i + start);\n  alphabetByEncoding[char] = i;\n  alphabetByValue[i] = char;\n}\n\nfor (let i = 0, start = \"a\".charCodeAt(0), limit = \"z\".charCodeAt(0); i + start <= limit; i++) {\n  const char = String.fromCharCode(i + start);\n  const index = i + 26;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\n\nfor (let i = 0; i < 10; i++) {\n  alphabetByEncoding[i.toString(10)] = i + 52;\n  const char = i.toString(10);\n  const index = i + 52;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\n\nalphabetByEncoding[\"+\"] = 62;\nalphabetByValue[62] = \"+\";\nalphabetByEncoding[\"/\"] = 63;\nalphabetByValue[63] = \"/\";\n\nconst bitsPerLetter = 6;\nconst bitsPerByte = 8;\nconst maxLetterValue = 0b111111;\n\n/**\n * Converts a base-64 encoded string to a Uint8Array of bytes.\n *\n * @param input The base-64 encoded string\n *\n * @see https://tools.ietf.org/html/rfc4648#section-4\n */\nexport function fromBase64(input: string): Uint8Array {\n  let totalByteLength = (input.length / 4) * 3;\n  if (input.substr(-2) === \"==\") {\n    totalByteLength -= 2;\n  } else if (input.substr(-1) === \"=\") {\n    totalByteLength--;\n  }\n  const out = new ArrayBuffer(totalByteLength);\n  const dataView = new DataView(out);\n  for (let i = 0; i < input.length; i += 4) {\n    let bits = 0;\n    let bitLength = 0;\n    for (let j = i, limit = i + 3; j <= limit; j++) {\n      if (input[j] !== \"=\") {\n        bits |= alphabetByEncoding[input[j]] << ((limit - j) * bitsPerLetter);\n        bitLength += bitsPerLetter;\n      } else {\n        bits >>= bitsPerLetter;\n      }\n    }\n\n    const chunkOffset = (i / 4) * 3;\n    bits >>= bitLength % bitsPerByte;\n    const byteLength = Math.floor(bitLength / bitsPerByte);\n    for (let k = 0; k < byteLength; k++) {\n      const offset = (byteLength - k - 1) * bitsPerByte;\n      dataView.setUint8(chunkOffset + k, (bits & (255 << offset)) >> offset);\n    }\n  }\n\n  return new Uint8Array(out);\n}\n\n/**\n * Converts a Uint8Array of binary data to a base-64 encoded string.\n *\n * @param input The binary data to encode\n *\n * @see https://tools.ietf.org/html/rfc4648#section-4\n */\nexport function toBase64(input: Uint8Array): string {\n  let str = \"\";\n  for (let i = 0; i < input.length; i += 3) {\n    let bits = 0;\n    let bitLength = 0;\n    for (let j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {\n      bits |= input[j] << ((limit - j - 1) * bitsPerByte);\n      bitLength += bitsPerByte;\n    }\n\n    const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);\n    bits <<= bitClusterCount * bitsPerLetter - bitLength;\n    for (let k = 1; k <= bitClusterCount; k++) {\n      const offset = (bitClusterCount - k) * bitsPerLetter;\n      str += alphabetByValue[(bits & (maxLetterValue << offset)) >> offset];\n    }\n\n    str += \"==\".slice(0, 4 - bitClusterCount);\n  }\n\n  return str;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
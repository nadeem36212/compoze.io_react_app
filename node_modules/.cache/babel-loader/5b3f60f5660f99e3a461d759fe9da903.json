{"ast":null,"code":"import _isPlainObject from \"lodash/isPlainObject\";\nimport _isFunction from \"lodash/isFunction\";\nimport _includes from \"lodash/includes\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\";\nimport * as d3Scale from \"victory-vendor/d3-scale\";\nvar supportedScaleStrings = [\"linear\", \"time\", \"log\", \"sqrt\"];\n\n// Private Functions\nfunction toNewName(scale) {\n  // d3 scale changed the naming scheme for scale from \"linear\" -> \"scaleLinear\" etc.\n  var capitalize = function capitalize(s) {\n    return s && s[0].toUpperCase() + s.slice(1);\n  };\n  return \"scale\".concat(capitalize(scale));\n}\nexport function validScale(scale) {\n  if (typeof scale === \"function\") {\n    return _isFunction(scale.copy) && _isFunction(scale.domain) && _isFunction(scale.range);\n  } else if (typeof scale === \"string\") {\n    return _includes(supportedScaleStrings, scale);\n  }\n  return false;\n}\nfunction isScaleDefined(props, axis) {\n  if (!props.scale) {\n    return false;\n  } else if (props.scale.x || props.scale.y) {\n    return !!props.scale[axis];\n  }\n  return true;\n}\nfunction getScaleTypeFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n  var scale = props.scale[axis] || props.scale;\n  return typeof scale === \"string\" ? scale : getType(scale);\n}\nfunction getScaleFromDomain(props, axis) {\n  var domain;\n  if (props.domain && props.domain[axis]) {\n    domain = props.domain[axis];\n  } else if (props.domain && Array.isArray(props.domain)) {\n    domain = props.domain;\n  }\n  if (!domain) {\n    return undefined;\n  }\n  return Collection.containsDates(domain) ? \"time\" : \"linear\";\n}\nfunction getScaleTypeFromData(props, axis) {\n  if (!props.data) {\n    return \"linear\";\n  }\n  var accessor = Helpers.createAccessor(props[axis]);\n  var axisData = props.data.map(function (datum) {\n    var processedData = _isPlainObject(accessor(datum)) ? accessor(datum)[axis] : accessor(datum);\n    return processedData !== undefined ? processedData : datum[axis];\n  });\n  return Collection.containsDates(axisData) ? \"time\" : \"linear\";\n} // Exported Functions\n\nexport function getScaleFromName(name) {\n  if (validScale(name)) {\n    var methodName = toNewName(name); // @ts-expect-error scaleTime is not directly compatible with our D3Scale definition\n\n    return d3Scale[methodName]();\n  }\n  return d3Scale.scaleLinear();\n}\nexport function getBaseScale(props, axis) {\n  var scale = getScaleFromProps(props, axis);\n  if (scale) {\n    return typeof scale === \"string\" ? getScaleFromName(scale) : scale;\n  }\n  var defaultScale = getScaleFromDomain(props, axis) || getScaleTypeFromData(props, axis);\n  return getScaleFromName(defaultScale);\n}\nexport function getDefaultScale() {\n  return d3Scale.scaleLinear();\n}\nexport function getScaleFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n  var scale = props.scale[axis] || props.scale;\n  if (validScale(scale)) {\n    return _isFunction(scale) ? scale : getScaleFromName(scale);\n  }\n  return undefined;\n}\nexport function getScaleType(props, axis) {\n  // if the scale was not given in props, it will be set to linear or time depending on data\n  return getScaleTypeFromProps(props, axis) || getScaleTypeFromData(props, axis);\n} // Ordered type inference off of function fields.\n// **Note**: Brittle because reliant on d3 internals.\n\nvar DUCK_TYPES = [{\n  name: \"quantile\",\n  method: \"quantiles\"\n}, {\n  name: \"log\",\n  method: \"base\"\n} // TODO(2214): Re-evaluate (1) duck typing approach, and (2) if duck typing,\n//   do we need a different approach? (Multiple keys? Stringifying functions?)\n// https://github.com/FormidableLabs/victory/issues/2214\n// Below are matches that don't seem to otherwise occur in Victory code base.\n// { name: \"ordinal\", method: \"unknown\" },\n// { name: \"pow-sqrt\", method: \"exponent\" },\n// { name: \"quantize-threshold\", method: \"invertExtent\" }\n];\n\nexport function getType(scale) {\n  if (typeof scale === \"string\") {\n    return scale;\n  }\n  var scaleType = DUCK_TYPES.filter(function (type) {\n    return scale[type.method] !== undefined;\n  })[0];\n  return scaleType ? scaleType.name : undefined;\n}","map":{"version":3,"names":["_isPlainObject","_isFunction","_includes","Helpers","Collection","d3Scale","supportedScaleStrings","toNewName","scale","capitalize","s","toUpperCase","slice","concat","validScale","copy","domain","range","isScaleDefined","props","axis","x","y","getScaleTypeFromProps","undefined","getType","getScaleFromDomain","Array","isArray","containsDates","getScaleTypeFromData","data","accessor","createAccessor","axisData","map","datum","processedData","getScaleFromName","name","methodName","scaleLinear","getBaseScale","getScaleFromProps","defaultScale","getDefaultScale","getScaleType","DUCK_TYPES","method","scaleType","filter","type"],"sources":["/Users/naeem/syntaxroot/compoze.io_react_app/node_modules/victory-core/es/victory-util/scale.js"],"sourcesContent":["import _isPlainObject from \"lodash/isPlainObject\";\nimport _isFunction from \"lodash/isFunction\";\nimport _includes from \"lodash/includes\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\";\nimport * as d3Scale from \"victory-vendor/d3-scale\";\nvar supportedScaleStrings = [\"linear\", \"time\", \"log\", \"sqrt\"];\n\n// Private Functions\nfunction toNewName(scale) {\n  // d3 scale changed the naming scheme for scale from \"linear\" -> \"scaleLinear\" etc.\n  var capitalize = function (s) {\n    return s && s[0].toUpperCase() + s.slice(1);\n  };\n\n  return \"scale\".concat(capitalize(scale));\n}\n\nexport function validScale(scale) {\n  if (typeof scale === \"function\") {\n    return _isFunction(scale.copy) && _isFunction(scale.domain) && _isFunction(scale.range);\n  } else if (typeof scale === \"string\") {\n    return _includes(supportedScaleStrings, scale);\n  }\n\n  return false;\n}\n\nfunction isScaleDefined(props, axis) {\n  if (!props.scale) {\n    return false;\n  } else if (props.scale.x || props.scale.y) {\n    return !!props.scale[axis];\n  }\n\n  return true;\n}\n\nfunction getScaleTypeFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n\n  var scale = props.scale[axis] || props.scale;\n  return typeof scale === \"string\" ? scale : getType(scale);\n}\n\nfunction getScaleFromDomain(props, axis) {\n  var domain;\n\n  if (props.domain && props.domain[axis]) {\n    domain = props.domain[axis];\n  } else if (props.domain && Array.isArray(props.domain)) {\n    domain = props.domain;\n  }\n\n  if (!domain) {\n    return undefined;\n  }\n\n  return Collection.containsDates(domain) ? \"time\" : \"linear\";\n}\n\nfunction getScaleTypeFromData(props, axis) {\n  if (!props.data) {\n    return \"linear\";\n  }\n\n  var accessor = Helpers.createAccessor(props[axis]);\n  var axisData = props.data.map(function (datum) {\n    var processedData = _isPlainObject(accessor(datum)) ? accessor(datum)[axis] : accessor(datum);\n    return processedData !== undefined ? processedData : datum[axis];\n  });\n  return Collection.containsDates(axisData) ? \"time\" : \"linear\";\n} // Exported Functions\n\n\nexport function getScaleFromName(name) {\n  if (validScale(name)) {\n    var methodName = toNewName(name); // @ts-expect-error scaleTime is not directly compatible with our D3Scale definition\n\n    return d3Scale[methodName]();\n  }\n\n  return d3Scale.scaleLinear();\n}\nexport function getBaseScale(props, axis) {\n  var scale = getScaleFromProps(props, axis);\n\n  if (scale) {\n    return typeof scale === \"string\" ? getScaleFromName(scale) : scale;\n  }\n\n  var defaultScale = getScaleFromDomain(props, axis) || getScaleTypeFromData(props, axis);\n  return getScaleFromName(defaultScale);\n}\nexport function getDefaultScale() {\n  return d3Scale.scaleLinear();\n}\nexport function getScaleFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n\n  var scale = props.scale[axis] || props.scale;\n\n  if (validScale(scale)) {\n    return _isFunction(scale) ? scale : getScaleFromName(scale);\n  }\n\n  return undefined;\n}\nexport function getScaleType(props, axis) {\n  // if the scale was not given in props, it will be set to linear or time depending on data\n  return getScaleTypeFromProps(props, axis) || getScaleTypeFromData(props, axis);\n} // Ordered type inference off of function fields.\n// **Note**: Brittle because reliant on d3 internals.\n\nvar DUCK_TYPES = [{\n  name: \"quantile\",\n  method: \"quantiles\"\n}, {\n  name: \"log\",\n  method: \"base\"\n} // TODO(2214): Re-evaluate (1) duck typing approach, and (2) if duck typing,\n//   do we need a different approach? (Multiple keys? Stringifying functions?)\n// https://github.com/FormidableLabs/victory/issues/2214\n// Below are matches that don't seem to otherwise occur in Victory code base.\n// { name: \"ordinal\", method: \"unknown\" },\n// { name: \"pow-sqrt\", method: \"exponent\" },\n// { name: \"quantize-threshold\", method: \"invertExtent\" }\n];\nexport function getType(scale) {\n  if (typeof scale === \"string\") {\n    return scale;\n  }\n\n  var scaleType = DUCK_TYPES.filter(function (type) {\n    return scale[type.method] !== undefined;\n  })[0];\n  return scaleType ? scaleType.name : undefined;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}
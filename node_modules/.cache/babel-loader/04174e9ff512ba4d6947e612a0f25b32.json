{"ast":null,"code":"import { NO_RETRY_INCREMENT, RETRY_COST, TIMEOUT_RETRY_COST } from \"./constants\";\nexport var getDefaultRetryQuota = function getDefaultRetryQuota(initialRetryTokens) {\n  var MAX_CAPACITY = initialRetryTokens;\n  var availableCapacity = initialRetryTokens;\n  var getCapacityAmount = function getCapacityAmount(error) {\n    return error.name === \"TimeoutError\" ? TIMEOUT_RETRY_COST : RETRY_COST;\n  };\n  var hasRetryTokens = function hasRetryTokens(error) {\n    return getCapacityAmount(error) <= availableCapacity;\n  };\n  var retrieveRetryTokens = function retrieveRetryTokens(error) {\n    if (!hasRetryTokens(error)) {\n      // retryStrategy should stop retrying, and return last error\n      throw new Error(\"No retry token available\");\n    }\n    var capacityAmount = getCapacityAmount(error);\n    availableCapacity -= capacityAmount;\n    return capacityAmount;\n  };\n  var releaseRetryTokens = function releaseRetryTokens(capacityReleaseAmount) {\n    availableCapacity += capacityReleaseAmount !== null && capacityReleaseAmount !== void 0 ? capacityReleaseAmount : NO_RETRY_INCREMENT;\n    availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);\n  };\n  return Object.freeze({\n    hasRetryTokens: hasRetryTokens,\n    retrieveRetryTokens: retrieveRetryTokens,\n    releaseRetryTokens: releaseRetryTokens\n  });\n};","map":{"version":3,"sources":["../../src/defaultRetryQuota.ts"],"names":[],"mappings":"AAEA,SAAS,kBAAkB,EAAE,UAAU,EAAE,kBAAkB,QAAQ,aAAa;AAGhF,OAAO,IAAM,oBAAoB,GAAG,SAAvB,oBAAoB,CAAI,kBAA0B,EAAA;EAC7D,IAAM,YAAY,GAAG,kBAAkB;EACvC,IAAI,iBAAiB,GAAG,kBAAkB;EAE1C,IAAM,iBAAiB,GAAG,SAApB,iBAAiB,CAAI,KAAe,EAAA;IAAK,OAAC,KAAK,CAAC,IAAI,KAAK,cAAc,GAAG,kBAAkB,GAAG,UAAU;EAAhE,CAAiE;EAEhH,IAAM,cAAc,GAAG,SAAjB,cAAc,CAAI,KAAe,EAAA;IAAK,OAAA,iBAAiB,CAAC,KAAK,CAAC,IAAI,iBAAiB;EAA7C,CAA6C;EAEzF,IAAM,mBAAmB,GAAG,SAAtB,mBAAmB,CAAI,KAAe,EAAA;IAC1C,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,EAAE;MAC1B;MACA,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC;IAC5C;IACD,IAAM,cAAc,GAAG,iBAAiB,CAAC,KAAK,CAAC;IAC/C,iBAAiB,IAAI,cAAc;IACnC,OAAO,cAAc;EACvB,CAAC;EAED,IAAM,kBAAkB,GAAG,SAArB,kBAAkB,CAAI,qBAA8B,EAAA;IACxD,iBAAiB,IAAI,qBAAqB,KAAA,IAAA,IAArB,qBAAqB,KAAA,KAAA,CAAA,GAArB,qBAAqB,GAAI,kBAAkB;IAChE,iBAAiB,GAAG,IAAI,CAAC,GAAG,CAAC,iBAAiB,EAAE,YAAY,CAAC;EAC/D,CAAC;EAED,OAAO,MAAM,CAAC,MAAM,CAAC;IACnB,cAAc,EAAA,cAAA;IACd,mBAAmB,EAAA,mBAAA;IACnB,kBAAkB,EAAA;GACnB,CAAC;AACJ,CAAC","sourcesContent":["import { SdkError } from \"@aws-sdk/smithy-client\";\n\nimport { NO_RETRY_INCREMENT, RETRY_COST, TIMEOUT_RETRY_COST } from \"./constants\";\nimport { RetryQuota } from \"./defaultStrategy\";\n\nexport const getDefaultRetryQuota = (initialRetryTokens: number): RetryQuota => {\n  const MAX_CAPACITY = initialRetryTokens;\n  let availableCapacity = initialRetryTokens;\n\n  const getCapacityAmount = (error: SdkError) => (error.name === \"TimeoutError\" ? TIMEOUT_RETRY_COST : RETRY_COST);\n\n  const hasRetryTokens = (error: SdkError) => getCapacityAmount(error) <= availableCapacity;\n\n  const retrieveRetryTokens = (error: SdkError) => {\n    if (!hasRetryTokens(error)) {\n      // retryStrategy should stop retrying, and return last error\n      throw new Error(\"No retry token available\");\n    }\n    const capacityAmount = getCapacityAmount(error);\n    availableCapacity -= capacityAmount;\n    return capacityAmount;\n  };\n\n  const releaseRetryTokens = (capacityReleaseAmount?: number) => {\n    availableCapacity += capacityReleaseAmount ?? NO_RETRY_INCREMENT;\n    availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);\n  };\n\n  return Object.freeze({\n    hasRetryTokens,\n    retrieveRetryTokens,\n    releaseRetryTokens,\n  });\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
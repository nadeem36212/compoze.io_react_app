{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Sha256 = void 0;\nvar util_1 = require(\"@aws-crypto/util\");\nvar constants_1 = require(\"./constants\");\nvar util_locate_window_1 = require(\"@aws-sdk/util-locate-window\");\nvar Sha256 = /** @class */function () {\n  function Sha256(secret) {\n    this.toHash = new Uint8Array(0);\n    if (secret !== void 0) {\n      this.key = new Promise(function (resolve, reject) {\n        (0, util_locate_window_1.locateWindow)().crypto.subtle.importKey(\"raw\", (0, util_1.convertToBuffer)(secret), constants_1.SHA_256_HMAC_ALGO, false, [\"sign\"]).then(resolve, reject);\n      });\n      this.key.catch(function () {});\n    }\n  }\n  Sha256.prototype.update = function (data) {\n    if ((0, util_1.isEmptyData)(data)) {\n      return;\n    }\n    var update = (0, util_1.convertToBuffer)(data);\n    var typedArray = new Uint8Array(this.toHash.byteLength + update.byteLength);\n    typedArray.set(this.toHash, 0);\n    typedArray.set(update, this.toHash.byteLength);\n    this.toHash = typedArray;\n  };\n  Sha256.prototype.digest = function () {\n    var _this = this;\n    if (this.key) {\n      return this.key.then(function (key) {\n        return (0, util_locate_window_1.locateWindow)().crypto.subtle.sign(constants_1.SHA_256_HMAC_ALGO, key, _this.toHash).then(function (data) {\n          return new Uint8Array(data);\n        });\n      });\n    }\n    if ((0, util_1.isEmptyData)(this.toHash)) {\n      return Promise.resolve(constants_1.EMPTY_DATA_SHA_256);\n    }\n    return Promise.resolve().then(function () {\n      return (0, util_locate_window_1.locateWindow)().crypto.subtle.digest(constants_1.SHA_256_HASH, _this.toHash);\n    }).then(function (data) {\n      return Promise.resolve(new Uint8Array(data));\n    });\n  };\n  return Sha256;\n}();\nexports.Sha256 = Sha256;","map":{"version":3,"sources":["../src/webCryptoSha256.ts"],"names":[],"mappings":";;;;;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AAKA,IAAA,oBAAA,GAAA,OAAA,CAAA,6BAAA,CAAA;AAEA,IAAA,MAAA,GAAA,aAAA,YAAA;EAIE,SAAA,MAAA,CAAY,MAAmB,EAAA;IAFvB,IAAA,CAAA,MAAM,GAAe,IAAI,UAAU,CAAC,CAAC,CAAC;IAG5C,IAAI,MAAM,KAAK,KAAK,CAAC,EAAE;MACrB,IAAI,CAAC,GAAG,GAAG,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM,EAAA;QACrC,CAAA,CAAA,EAAA,oBAAA,CAAA,YAAY,GAAE,CACX,MAAM,CAAC,MAAM,CAAC,SAAS,CACtB,KAAK,EACL,CAAA,CAAA,EAAA,MAAA,CAAA,eAAe,EAAC,MAAM,CAAC,EACvB,WAAA,CAAA,iBAAiB,EACjB,KAAK,EACL,CAAC,MAAM,CAAC,CACT,CACA,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC;MAC1B,CAAC,CAAC;MACF,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,YAAA,CAAO,CAAC,CAAC;IACzB;EACH;EAEA,MAAA,CAAA,SAAA,CAAA,MAAM,GAAN,UAAO,IAAgB,EAAA;IACrB,IAAI,CAAA,CAAA,EAAA,MAAA,CAAA,WAAW,EAAC,IAAI,CAAC,EAAE;MACrB;IACD;IAED,IAAM,MAAM,GAAG,CAAA,CAAA,EAAA,MAAA,CAAA,eAAe,EAAC,IAAI,CAAC;IACpC,IAAM,UAAU,GAAG,IAAI,UAAU,CAC/B,IAAI,CAAC,MAAM,CAAC,UAAU,GAAG,MAAM,CAAC,UAAU,CAC3C;IACD,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC;IAC9B,UAAU,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC;IAC9C,IAAI,CAAC,MAAM,GAAG,UAAU;EAC1B,CAAC;EAED,MAAA,CAAA,SAAA,CAAA,MAAM,GAAN,YAAA;IAAA,IAAA,KAAA,GAAA,IAAA;IACE,IAAI,IAAI,CAAC,GAAG,EAAE;MACZ,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,UAAC,GAAG,EAAA;QACvB,OAAA,CAAA,CAAA,EAAA,oBAAA,CAAA,YAAY,GAAE,CACX,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,WAAA,CAAA,iBAAiB,EAAE,GAAG,EAAE,KAAI,CAAC,MAAM,CAAC,CACvD,IAAI,CAAC,UAAC,IAAI,EAAA;UAAK,OAAA,IAAI,UAAU,CAAC,IAAI,CAAC;QAApB,CAAoB,CAAC;MAFvC,CAEuC,CACxC;IACF;IAED,IAAI,CAAA,CAAA,EAAA,MAAA,CAAA,WAAW,EAAC,IAAI,CAAC,MAAM,CAAC,EAAE;MAC5B,OAAO,OAAO,CAAC,OAAO,CAAC,WAAA,CAAA,kBAAkB,CAAC;IAC3C;IAED,OAAO,OAAO,CAAC,OAAO,EAAE,CACrB,IAAI,CAAC,YAAA;MACJ,OAAA,CAAA,CAAA,EAAA,oBAAA,CAAA,YAAY,GAAE,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,WAAA,CAAA,YAAY,EAAE,KAAI,CAAC,MAAM,CAAC;IAA9D,CAA8D,CAC/D,CACA,IAAI,CAAC,UAAC,IAAI,EAAA;MAAK,OAAA,OAAO,CAAC,OAAO,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC;IAArC,CAAqC,CAAC;EAC1D,CAAC;EACH,OAAA,MAAC;AAAD,CAAC,EAAA;AAtDY,OAAA,CAAA,MAAA,GAAA,MAAA","sourcesContent":["import { Hash, SourceData } from \"@aws-sdk/types\";\nimport { isEmptyData, convertToBuffer } from \"@aws-crypto/util\";\nimport {\n  EMPTY_DATA_SHA_256,\n  SHA_256_HASH,\n  SHA_256_HMAC_ALGO,\n} from \"./constants\";\nimport { locateWindow } from \"@aws-sdk/util-locate-window\";\n\nexport class Sha256 implements Hash {\n  private readonly key: Promise<CryptoKey> | undefined;\n  private toHash: Uint8Array = new Uint8Array(0);\n\n  constructor(secret?: SourceData) {\n    if (secret !== void 0) {\n      this.key = new Promise((resolve, reject) => {\n        locateWindow()\n          .crypto.subtle.importKey(\n            \"raw\",\n            convertToBuffer(secret),\n            SHA_256_HMAC_ALGO,\n            false,\n            [\"sign\"]\n          )\n          .then(resolve, reject);\n      });\n      this.key.catch(() => {});\n    }\n  }\n\n  update(data: SourceData): void {\n    if (isEmptyData(data)) {\n      return;\n    }\n\n    const update = convertToBuffer(data);\n    const typedArray = new Uint8Array(\n      this.toHash.byteLength + update.byteLength\n    );\n    typedArray.set(this.toHash, 0);\n    typedArray.set(update, this.toHash.byteLength);\n    this.toHash = typedArray;\n  }\n\n  digest(): Promise<Uint8Array> {\n    if (this.key) {\n      return this.key.then((key) =>\n        locateWindow()\n          .crypto.subtle.sign(SHA_256_HMAC_ALGO, key, this.toHash)\n          .then((data) => new Uint8Array(data))\n      );\n    }\n\n    if (isEmptyData(this.toHash)) {\n      return Promise.resolve(EMPTY_DATA_SHA_256);\n    }\n\n    return Promise.resolve()\n      .then(() =>\n        locateWindow().crypto.subtle.digest(SHA_256_HASH, this.toHash)\n      )\n      .then((data) => Promise.resolve(new Uint8Array(data)));\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}
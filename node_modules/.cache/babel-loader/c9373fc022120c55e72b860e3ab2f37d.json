{"ast":null,"code":"import { __read } from \"tslib\";\n/**\n * @internal\n */\nexport function resolveLogins(logins) {\n  return Promise.all(Object.keys(logins).reduce(function (arr, name) {\n    var tokenOrProvider = logins[name];\n    if (typeof tokenOrProvider === \"string\") {\n      arr.push([name, tokenOrProvider]);\n    } else {\n      arr.push(tokenOrProvider().then(function (token) {\n        return [name, token];\n      }));\n    }\n    return arr;\n  }, [])).then(function (resolvedPairs) {\n    return resolvedPairs.reduce(function (logins, _a) {\n      var _b = __read(_a, 2),\n        key = _b[0],\n        value = _b[1];\n      logins[key] = value;\n      return logins;\n    }, {});\n  });\n}","map":{"version":3,"sources":["../../src/resolveLogins.ts"],"names":[],"mappings":";AAEA;;AAEG;AACH,OAAM,SAAU,aAAa,CAAC,MAAc,EAAA;EAC1C,OAAO,OAAO,CAAC,GAAG,CAChB,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,UAAC,GAAwD,EAAE,IAAY,EAAA;IAChG,IAAM,eAAe,GAAG,MAAM,CAAC,IAAI,CAAC;IACpC,IAAI,OAAO,eAAe,KAAK,QAAQ,EAAE;MACvC,GAAG,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,eAAe,CAAqB,CAAC;KACtD,MAAM;MACL,GAAG,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC,IAAI,CAAC,UAAC,KAAK,EAAA;QAAK,OAAA,CAAC,IAAI,EAAE,KAAK,CAAqB;MAAjC,CAAiC,CAAC,CAAC;IAC/E;IACD,OAAO,GAAG;EACZ,CAAC,EAAE,EAAsC,CAAC,CAC3C,CAAC,IAAI,CAAC,UAAC,aAAa,EAAA;IACnB,OAAA,aAAa,CAAC,MAAM,CAAC,UAAC,MAAsB,EAAE,EAAY,EAAA;UAAZ,EAAA,GAAA,MAAA,CAAA,EAAA,EAAA,CAAA,CAAY;QAAX,GAAG,GAAA,EAAA,CAAA,CAAA,CAAA;QAAE,KAAK,GAAA,EAAA,CAAA,CAAA,CAAA;MACvD,MAAM,CAAC,GAAG,CAAC,GAAG,KAAK;MACnB,OAAO,MAAM;IACf,CAAC,EAAE,CAAA,CAAoB,CAAC;EAHxB,CAGwB,CACzB;AACH","sourcesContent":["import { Logins, ResolvedLogins } from \"./Logins\";\n\n/**\n * @internal\n */\nexport function resolveLogins(logins: Logins): Promise<ResolvedLogins> {\n  return Promise.all(\n    Object.keys(logins).reduce((arr: Array<[string, string] | Promise<[string, string]>>, name: string) => {\n      const tokenOrProvider = logins[name];\n      if (typeof tokenOrProvider === \"string\") {\n        arr.push([name, tokenOrProvider] as [string, string]);\n      } else {\n        arr.push(tokenOrProvider().then((token) => [name, token] as [string, string]));\n      }\n      return arr;\n    }, [] as Array<Promise<[string, string]>>)\n  ).then((resolvedPairs) =>\n    resolvedPairs.reduce((logins: ResolvedLogins, [key, value]) => {\n      logins[key] = value;\n      return logins;\n    }, {} as ResolvedLogins)\n  );\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { toHex } from \"@aws-sdk/util-hex-encoding\";\nimport { ALGORITHM_IDENTIFIER, ALGORITHM_QUERY_PARAM, AMZ_DATE_HEADER, AMZ_DATE_QUERY_PARAM, AUTH_HEADER, CREDENTIAL_QUERY_PARAM, EVENT_ALGORITHM_IDENTIFIER, EXPIRES_QUERY_PARAM, MAX_PRESIGNED_TTL, SHA256_HEADER, SIGNATURE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, TOKEN_HEADER, TOKEN_QUERY_PARAM } from \"./constants\";\nimport { createScope, getSigningKey } from \"./credentialDerivation\";\nimport { getCanonicalHeaders } from \"./getCanonicalHeaders\";\nimport { getCanonicalQuery } from \"./getCanonicalQuery\";\nimport { getPayloadHash } from \"./getPayloadHash\";\nimport { hasHeader } from \"./hasHeader\";\nimport { moveHeadersToQuery } from \"./moveHeadersToQuery\";\nimport { prepareRequest } from \"./prepareRequest\";\nimport { iso8601 } from \"./utilDate\";\nvar SignatureV4 = /** @class */function () {\n  function SignatureV4(_a) {\n    var applyChecksum = _a.applyChecksum,\n      credentials = _a.credentials,\n      region = _a.region,\n      service = _a.service,\n      sha256 = _a.sha256,\n      _b = _a.uriEscapePath,\n      uriEscapePath = _b === void 0 ? true : _b;\n    this.service = service;\n    this.sha256 = sha256;\n    this.uriEscapePath = uriEscapePath;\n    // default to true if applyChecksum isn't set\n    this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n    this.regionProvider = normalizeRegionProvider(region);\n    this.credentialProvider = normalizeCredentialsProvider(credentials);\n  }\n  SignatureV4.prototype.presign = function (originalRequest, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, signingDate, _b, expiresIn, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService, credentials, region, _c, _d, longDate, shortDate, scope, request, canonicalHeaders, _e, _f, _g, _h, _j, _k;\n      return __generator(this, function (_l) {\n        switch (_l.label) {\n          case 0:\n            _a = options.signingDate, signingDate = _a === void 0 ? new Date() : _a, _b = options.expiresIn, expiresIn = _b === void 0 ? 3600 : _b, unsignableHeaders = options.unsignableHeaders, unhoistableHeaders = options.unhoistableHeaders, signableHeaders = options.signableHeaders, signingRegion = options.signingRegion, signingService = options.signingService;\n            return [4 /*yield*/, this.credentialProvider()];\n          case 1:\n            credentials = _l.sent();\n            if (!(signingRegion !== null && signingRegion !== void 0)) return [3 /*break*/, 2];\n            _c = signingRegion;\n            return [3 /*break*/, 4];\n          case 2:\n            return [4 /*yield*/, this.regionProvider()];\n          case 3:\n            _c = _l.sent();\n            _l.label = 4;\n          case 4:\n            region = _c;\n            _d = formatDate(signingDate), longDate = _d.longDate, shortDate = _d.shortDate;\n            if (expiresIn > MAX_PRESIGNED_TTL) {\n              return [2 /*return*/, Promise.reject(\"Signature version 4 presigned URLs\" + \" must have an expiration date less than one week in\" + \" the future\")];\n            }\n            scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\n            request = moveHeadersToQuery(prepareRequest(originalRequest), {\n              unhoistableHeaders: unhoistableHeaders\n            });\n            if (credentials.sessionToken) {\n              request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;\n            }\n            request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;\n            request.query[CREDENTIAL_QUERY_PARAM] = credentials.accessKeyId + \"/\" + scope;\n            request.query[AMZ_DATE_QUERY_PARAM] = longDate;\n            request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\n            canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n            request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);\n            _e = request.query;\n            _f = SIGNATURE_QUERY_PARAM;\n            _g = this.getSignature;\n            _h = [longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService)];\n            _j = this.createCanonicalRequest;\n            _k = [request, canonicalHeaders];\n            return [4 /*yield*/, getPayloadHash(originalRequest, this.sha256)];\n          case 5:\n            return [4 /*yield*/, _g.apply(this, _h.concat([_j.apply(this, _k.concat([_l.sent()]))]))];\n          case 6:\n            _e[_f] = _l.sent();\n            return [2 /*return*/, request];\n        }\n      });\n    });\n  };\n  SignatureV4.prototype.sign = function (toSign, options) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (typeof toSign === \"string\") {\n          return [2 /*return*/, this.signString(toSign, options)];\n        } else if (toSign.headers && toSign.payload) {\n          return [2 /*return*/, this.signEvent(toSign, options)];\n        } else {\n          return [2 /*return*/, this.signRequest(toSign, options)];\n        }\n        return [2 /*return*/];\n      });\n    });\n  };\n\n  SignatureV4.prototype.signEvent = function (_a, _b) {\n    var headers = _a.headers,\n      payload = _a.payload;\n    var _c = _b.signingDate,\n      signingDate = _c === void 0 ? new Date() : _c,\n      priorSignature = _b.priorSignature,\n      signingRegion = _b.signingRegion,\n      signingService = _b.signingService;\n    return __awaiter(this, void 0, void 0, function () {\n      var region, _d, _e, shortDate, longDate, scope, hashedPayload, hash, hashedHeaders, _f, stringToSign;\n      return __generator(this, function (_g) {\n        switch (_g.label) {\n          case 0:\n            if (!(signingRegion !== null && signingRegion !== void 0)) return [3 /*break*/, 1];\n            _d = signingRegion;\n            return [3 /*break*/, 3];\n          case 1:\n            return [4 /*yield*/, this.regionProvider()];\n          case 2:\n            _d = _g.sent();\n            _g.label = 3;\n          case 3:\n            region = _d;\n            _e = formatDate(signingDate), shortDate = _e.shortDate, longDate = _e.longDate;\n            scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\n            return [4 /*yield*/, getPayloadHash({\n              headers: {},\n              body: payload\n            }, this.sha256)];\n          case 4:\n            hashedPayload = _g.sent();\n            hash = new this.sha256();\n            hash.update(headers);\n            _f = toHex;\n            return [4 /*yield*/, hash.digest()];\n          case 5:\n            hashedHeaders = _f.apply(void 0, [_g.sent()]);\n            stringToSign = [EVENT_ALGORITHM_IDENTIFIER, longDate, scope, priorSignature, hashedHeaders, hashedPayload].join(\"\\n\");\n            return [2 /*return*/, this.signString(stringToSign, {\n              signingDate: signingDate,\n              signingRegion: region,\n              signingService: signingService\n            })];\n        }\n      });\n    });\n  };\n  SignatureV4.prototype.signString = function (stringToSign, _a) {\n    var _b = _a === void 0 ? {} : _a,\n      _c = _b.signingDate,\n      signingDate = _c === void 0 ? new Date() : _c,\n      signingRegion = _b.signingRegion,\n      signingService = _b.signingService;\n    return __awaiter(this, void 0, void 0, function () {\n      var credentials, region, _d, shortDate, hash, _e, _f, _g;\n      return __generator(this, function (_h) {\n        switch (_h.label) {\n          case 0:\n            return [4 /*yield*/, this.credentialProvider()];\n          case 1:\n            credentials = _h.sent();\n            if (!(signingRegion !== null && signingRegion !== void 0)) return [3 /*break*/, 2];\n            _d = signingRegion;\n            return [3 /*break*/, 4];\n          case 2:\n            return [4 /*yield*/, this.regionProvider()];\n          case 3:\n            _d = _h.sent();\n            _h.label = 4;\n          case 4:\n            region = _d;\n            shortDate = formatDate(signingDate).shortDate;\n            _f = (_e = this.sha256).bind;\n            return [4 /*yield*/, this.getSigningKey(credentials, region, shortDate, signingService)];\n          case 5:\n            hash = new (_f.apply(_e, [void 0, _h.sent()]))();\n            hash.update(stringToSign);\n            _g = toHex;\n            return [4 /*yield*/, hash.digest()];\n          case 6:\n            return [2 /*return*/, _g.apply(void 0, [_h.sent()])];\n        }\n      });\n    });\n  };\n  SignatureV4.prototype.signRequest = function (requestToSign, _a) {\n    var _b = _a === void 0 ? {} : _a,\n      _c = _b.signingDate,\n      signingDate = _c === void 0 ? new Date() : _c,\n      signableHeaders = _b.signableHeaders,\n      unsignableHeaders = _b.unsignableHeaders,\n      signingRegion = _b.signingRegion,\n      signingService = _b.signingService;\n    return __awaiter(this, void 0, void 0, function () {\n      var credentials, region, _d, request, _e, longDate, shortDate, scope, payloadHash, canonicalHeaders, signature;\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            return [4 /*yield*/, this.credentialProvider()];\n          case 1:\n            credentials = _f.sent();\n            if (!(signingRegion !== null && signingRegion !== void 0)) return [3 /*break*/, 2];\n            _d = signingRegion;\n            return [3 /*break*/, 4];\n          case 2:\n            return [4 /*yield*/, this.regionProvider()];\n          case 3:\n            _d = _f.sent();\n            _f.label = 4;\n          case 4:\n            region = _d;\n            request = prepareRequest(requestToSign);\n            _e = formatDate(signingDate), longDate = _e.longDate, shortDate = _e.shortDate;\n            scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\n            request.headers[AMZ_DATE_HEADER] = longDate;\n            if (credentials.sessionToken) {\n              request.headers[TOKEN_HEADER] = credentials.sessionToken;\n            }\n            return [4 /*yield*/, getPayloadHash(request, this.sha256)];\n          case 5:\n            payloadHash = _f.sent();\n            if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {\n              request.headers[SHA256_HEADER] = payloadHash;\n            }\n            canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n            return [4 /*yield*/, this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash))];\n          case 6:\n            signature = _f.sent();\n            request.headers[AUTH_HEADER] = ALGORITHM_IDENTIFIER + \" \" + (\"Credential=\" + credentials.accessKeyId + \"/\" + scope + \", \") + (\"SignedHeaders=\" + getCanonicalHeaderList(canonicalHeaders) + \", \") + (\"Signature=\" + signature);\n            return [2 /*return*/, request];\n        }\n      });\n    });\n  };\n  SignatureV4.prototype.createCanonicalRequest = function (request, canonicalHeaders, payloadHash) {\n    var sortedHeaders = Object.keys(canonicalHeaders).sort();\n    return request.method + \"\\n\" + this.getCanonicalPath(request) + \"\\n\" + getCanonicalQuery(request) + \"\\n\" + sortedHeaders.map(function (name) {\n      return name + \":\" + canonicalHeaders[name];\n    }).join(\"\\n\") + \"\\n\\n\" + sortedHeaders.join(\";\") + \"\\n\" + payloadHash;\n  };\n  SignatureV4.prototype.createStringToSign = function (longDate, credentialScope, canonicalRequest) {\n    return __awaiter(this, void 0, void 0, function () {\n      var hash, hashedRequest;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            hash = new this.sha256();\n            hash.update(canonicalRequest);\n            return [4 /*yield*/, hash.digest()];\n          case 1:\n            hashedRequest = _a.sent();\n            return [2 /*return*/, ALGORITHM_IDENTIFIER + \"\\n\" + longDate + \"\\n\" + credentialScope + \"\\n\" + toHex(hashedRequest)];\n        }\n      });\n    });\n  };\n  SignatureV4.prototype.getCanonicalPath = function (_a) {\n    var path = _a.path;\n    if (this.uriEscapePath) {\n      var doubleEncoded = encodeURIComponent(path.replace(/^\\//, \"\"));\n      return \"/\" + doubleEncoded.replace(/%2F/g, \"/\");\n    }\n    return path;\n  };\n  SignatureV4.prototype.getSignature = function (longDate, credentialScope, keyPromise, canonicalRequest) {\n    return __awaiter(this, void 0, void 0, function () {\n      var stringToSign, hash, _a, _b, _c;\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            return [4 /*yield*/, this.createStringToSign(longDate, credentialScope, canonicalRequest)];\n          case 1:\n            stringToSign = _d.sent();\n            _b = (_a = this.sha256).bind;\n            return [4 /*yield*/, keyPromise];\n          case 2:\n            hash = new (_b.apply(_a, [void 0, _d.sent()]))();\n            hash.update(stringToSign);\n            _c = toHex;\n            return [4 /*yield*/, hash.digest()];\n          case 3:\n            return [2 /*return*/, _c.apply(void 0, [_d.sent()])];\n        }\n      });\n    });\n  };\n  SignatureV4.prototype.getSigningKey = function (credentials, region, shortDate, service) {\n    return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);\n  };\n  return SignatureV4;\n}();\nexport { SignatureV4 };\nvar formatDate = function formatDate(now) {\n  var longDate = iso8601(now).replace(/[\\-:]/g, \"\");\n  return {\n    longDate: longDate,\n    shortDate: longDate.substr(0, 8)\n  };\n};\nvar getCanonicalHeaderList = function getCanonicalHeaderList(headers) {\n  return Object.keys(headers).sort().join(\";\");\n};\nvar normalizeRegionProvider = function normalizeRegionProvider(region) {\n  if (typeof region === \"string\") {\n    var promisified_1 = Promise.resolve(region);\n    return function () {\n      return promisified_1;\n    };\n  } else {\n    return region;\n  }\n};\nvar normalizeCredentialsProvider = function normalizeCredentialsProvider(credentials) {\n  if (typeof credentials === \"object\") {\n    var promisified_2 = Promise.resolve(credentials);\n    return function () {\n      return promisified_2;\n    };\n  } else {\n    return credentials;\n  }\n};","map":{"version":3,"sources":["../../src/SignatureV4.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Credentials,\n  DateInput,\n  EventSigner,\n  EventSigningArguments,\n  FormattedEvent,\n  HashConstructor,\n  HeaderBag,\n  HttpRequest,\n  Provider,\n  RequestPresigner,\n  RequestPresigningArguments,\n  RequestSigner,\n  RequestSigningArguments,\n  SigningArguments,\n  StringSigner,\n} from \"@aws-sdk/types\";\nimport { toHex } from \"@aws-sdk/util-hex-encoding\";\n\nimport {\n  ALGORITHM_IDENTIFIER,\n  ALGORITHM_QUERY_PARAM,\n  AMZ_DATE_HEADER,\n  AMZ_DATE_QUERY_PARAM,\n  AUTH_HEADER,\n  CREDENTIAL_QUERY_PARAM,\n  EVENT_ALGORITHM_IDENTIFIER,\n  EXPIRES_QUERY_PARAM,\n  MAX_PRESIGNED_TTL,\n  SHA256_HEADER,\n  SIGNATURE_QUERY_PARAM,\n  SIGNED_HEADERS_QUERY_PARAM,\n  TOKEN_HEADER,\n  TOKEN_QUERY_PARAM,\n} from \"./constants\";\nimport { createScope, getSigningKey } from \"./credentialDerivation\";\nimport { getCanonicalHeaders } from \"./getCanonicalHeaders\";\nimport { getCanonicalQuery } from \"./getCanonicalQuery\";\nimport { getPayloadHash } from \"./getPayloadHash\";\nimport { hasHeader } from \"./hasHeader\";\nimport { moveHeadersToQuery } from \"./moveHeadersToQuery\";\nimport { prepareRequest } from \"./prepareRequest\";\nimport { iso8601 } from \"./utilDate\";\n\nexport interface SignatureV4Init {\n  /**\n   * The service signing name.\n   */\n  service: string;\n\n  /**\n   * The region name or a function that returns a promise that will be\n   * resolved with the region name.\n   */\n  region: string | Provider<string>;\n\n  /**\n   * The credentials with which the request should be signed or a function\n   * that returns a promise that will be resolved with credentials.\n   */\n  credentials: Credentials | Provider<Credentials>;\n\n  /**\n   * A constructor function for a hash object that will calculate SHA-256 HMAC\n   * checksums.\n   */\n  sha256?: HashConstructor;\n\n  /**\n   * Whether to uri-escape the request URI path as part of computing the\n   * canonical request string. This is required for every AWS service, except\n   * Amazon S3, as of late 2017.\n   *\n   * @default [true]\n   */\n  uriEscapePath?: boolean;\n\n  /**\n   * Whether to calculate a checksum of the request body and include it as\n   * either a request header (when signing) or as a query string parameter\n   * (when presigning). This is required for AWS Glacier and Amazon S3 and optional for\n   * every other AWS service as of late 2017.\n   *\n   * @default [true]\n   */\n  applyChecksum?: boolean;\n}\n\nexport interface SignatureV4CryptoInit {\n  sha256: HashConstructor;\n}\n\nexport class SignatureV4 implements RequestPresigner, RequestSigner, StringSigner, EventSigner {\n  private readonly service: string;\n  private readonly regionProvider: Provider<string>;\n  private readonly credentialProvider: Provider<Credentials>;\n  private readonly sha256: HashConstructor;\n  private readonly uriEscapePath: boolean;\n  private readonly applyChecksum: boolean;\n\n  constructor({\n    applyChecksum,\n    credentials,\n    region,\n    service,\n    sha256,\n    uriEscapePath = true,\n  }: SignatureV4Init & SignatureV4CryptoInit) {\n    this.service = service;\n    this.sha256 = sha256;\n    this.uriEscapePath = uriEscapePath;\n    // default to true if applyChecksum isn't set\n    this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n    this.regionProvider = normalizeRegionProvider(region);\n    this.credentialProvider = normalizeCredentialsProvider(credentials);\n  }\n\n  public async presign(originalRequest: HttpRequest, options: RequestPresigningArguments = {}): Promise<HttpRequest> {\n    const {\n      signingDate = new Date(),\n      expiresIn = 3600,\n      unsignableHeaders,\n      unhoistableHeaders,\n      signableHeaders,\n      signingRegion,\n      signingService,\n    } = options;\n    const credentials = await this.credentialProvider();\n    const region = signingRegion ?? (await this.regionProvider());\n\n    const { longDate, shortDate } = formatDate(signingDate);\n    if (expiresIn > MAX_PRESIGNED_TTL) {\n      return Promise.reject(\n        \"Signature version 4 presigned URLs\" + \" must have an expiration date less than one week in\" + \" the future\"\n      );\n    }\n\n    const scope = createScope(shortDate, region, signingService ?? this.service);\n    const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders });\n\n    if (credentials.sessionToken) {\n      request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;\n    }\n    request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;\n    request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;\n    request.query[AMZ_DATE_QUERY_PARAM] = longDate;\n    request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\n\n    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n    request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);\n\n    request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(\n      longDate,\n      scope,\n      this.getSigningKey(credentials, region, shortDate, signingService),\n      this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256))\n    );\n\n    return request;\n  }\n\n  public async sign(stringToSign: string, options?: SigningArguments): Promise<string>;\n  public async sign(event: FormattedEvent, options: EventSigningArguments): Promise<string>;\n  public async sign(requestToSign: HttpRequest, options?: RequestSigningArguments): Promise<HttpRequest>;\n  public async sign(toSign: any, options: any): Promise<any> {\n    if (typeof toSign === \"string\") {\n      return this.signString(toSign, options);\n    } else if (toSign.headers && toSign.payload) {\n      return this.signEvent(toSign, options);\n    } else {\n      return this.signRequest(toSign, options);\n    }\n  }\n\n  private async signEvent(\n    { headers, payload }: FormattedEvent,\n    { signingDate = new Date(), priorSignature, signingRegion, signingService }: EventSigningArguments\n  ): Promise<string> {\n    const region = signingRegion ?? (await this.regionProvider());\n    const { shortDate, longDate } = formatDate(signingDate);\n    const scope = createScope(shortDate, region, signingService ?? this.service);\n    const hashedPayload = await getPayloadHash({ headers: {}, body: payload } as any, this.sha256);\n    const hash = new this.sha256();\n    hash.update(headers);\n    const hashedHeaders = toHex(await hash.digest());\n    const stringToSign = [\n      EVENT_ALGORITHM_IDENTIFIER,\n      longDate,\n      scope,\n      priorSignature,\n      hashedHeaders,\n      hashedPayload,\n    ].join(\"\\n\");\n    return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });\n  }\n\n  private async signString(\n    stringToSign: string,\n    { signingDate = new Date(), signingRegion, signingService }: SigningArguments = {}\n  ): Promise<string> {\n    const credentials = await this.credentialProvider();\n    const region = signingRegion ?? (await this.regionProvider());\n    const { shortDate } = formatDate(signingDate);\n\n    const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));\n    hash.update(stringToSign);\n    return toHex(await hash.digest());\n  }\n\n  private async signRequest(\n    requestToSign: HttpRequest,\n    {\n      signingDate = new Date(),\n      signableHeaders,\n      unsignableHeaders,\n      signingRegion,\n      signingService,\n    }: RequestSigningArguments = {}\n  ): Promise<HttpRequest> {\n    const credentials = await this.credentialProvider();\n    const region = signingRegion ?? (await this.regionProvider());\n    const request = prepareRequest(requestToSign);\n    const { longDate, shortDate } = formatDate(signingDate);\n    const scope = createScope(shortDate, region, signingService ?? this.service);\n\n    request.headers[AMZ_DATE_HEADER] = longDate;\n    if (credentials.sessionToken) {\n      request.headers[TOKEN_HEADER] = credentials.sessionToken;\n    }\n\n    const payloadHash = await getPayloadHash(request, this.sha256);\n    if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {\n      request.headers[SHA256_HEADER] = payloadHash;\n    }\n\n    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n    const signature = await this.getSignature(\n      longDate,\n      scope,\n      this.getSigningKey(credentials, region, shortDate, signingService),\n      this.createCanonicalRequest(request, canonicalHeaders, payloadHash)\n    );\n\n    request.headers[AUTH_HEADER] =\n      `${ALGORITHM_IDENTIFIER} ` +\n      `Credential=${credentials.accessKeyId}/${scope}, ` +\n      `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` +\n      `Signature=${signature}`;\n\n    return request;\n  }\n\n  private createCanonicalRequest(request: HttpRequest, canonicalHeaders: HeaderBag, payloadHash: string): string {\n    const sortedHeaders = Object.keys(canonicalHeaders).sort();\n    return `${request.method}\n${this.getCanonicalPath(request)}\n${getCanonicalQuery(request)}\n${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join(\"\\n\")}\n\n${sortedHeaders.join(\";\")}\n${payloadHash}`;\n  }\n\n  private async createStringToSign(\n    longDate: string,\n    credentialScope: string,\n    canonicalRequest: string\n  ): Promise<string> {\n    const hash = new this.sha256();\n    hash.update(canonicalRequest);\n    const hashedRequest = await hash.digest();\n\n    return `${ALGORITHM_IDENTIFIER}\n${longDate}\n${credentialScope}\n${toHex(hashedRequest)}`;\n  }\n\n  private getCanonicalPath({ path }: HttpRequest): string {\n    if (this.uriEscapePath) {\n      const doubleEncoded = encodeURIComponent(path.replace(/^\\//, \"\"));\n      return `/${doubleEncoded.replace(/%2F/g, \"/\")}`;\n    }\n\n    return path;\n  }\n\n  private async getSignature(\n    longDate: string,\n    credentialScope: string,\n    keyPromise: Promise<Uint8Array>,\n    canonicalRequest: string\n  ): Promise<string> {\n    const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);\n\n    const hash = new this.sha256(await keyPromise);\n    hash.update(stringToSign);\n    return toHex(await hash.digest());\n  }\n\n  private getSigningKey(\n    credentials: Credentials,\n    region: string,\n    shortDate: string,\n    service?: string\n  ): Promise<Uint8Array> {\n    return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);\n  }\n}\n\nconst formatDate = (now: DateInput): { longDate: string; shortDate: string } => {\n  const longDate = iso8601(now).replace(/[\\-:]/g, \"\");\n  return {\n    longDate,\n    shortDate: longDate.substr(0, 8),\n  };\n};\n\nconst getCanonicalHeaderList = (headers: object): string => Object.keys(headers).sort().join(\";\");\n\nconst normalizeRegionProvider = (region: string | Provider<string>): Provider<string> => {\n  if (typeof region === \"string\") {\n    const promisified = Promise.resolve(region);\n    return () => promisified;\n  } else {\n    return region;\n  }\n};\n\nconst normalizeCredentialsProvider = (credentials: Credentials | Provider<Credentials>): Provider<Credentials> => {\n  if (typeof credentials === \"object\") {\n    const promisified = Promise.resolve(credentials);\n    return () => promisified;\n  } else {\n    return credentials;\n  }\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}